================================================
FILE: README.md
================================================
# DROMA.R: Drug Omics Association Analysis Extension for DROMA.Set

[![Version](https://img.shields.io/badge/version-0.9.0-blue.svg)](https://github.com/mugpeng/DROMA_R)

## Overview

**DROMA.R** is an R package that provides advanced analysis functions for drug-omics associations using DromaSet and MultiDromaSet objects from the **DROMA.Set** package. It supports meta-analysis of drug-omics associations across multiple datasets, comprehensive visualization tools, and batch processing of features. This package extends DROMA.Set with statistical analysis capabilities for biomarker discovery in precision medicine. **All data loading functions now apply z-score normalization by default** for improved analysis consistency.

## Features

- **ðŸ”— DROMA.Set Integration**: Works seamlessly with DromaSet and MultiDromaSet objects
- **ðŸ“Š Meta-analysis**: Advanced statistical analysis across multiple datasets
- **ðŸŽ¨ Comprehensive Visualization**: Forest plots, volcano plots, comparison plots with consistent theming
- **âš¡ Batch Processing**: Efficient analysis of multiple features simultaneously
- **ðŸ§® Multiple Statistical Methods**: Spearman correlation, Wilcoxon tests, Cliff's Delta effect sizes
- **ðŸš€ Performance Optimization**: Parallel processing support for large datasets
- **ðŸ”„ Z-score Normalization**: All data loading functions apply z-score normalization by default

## Installation

### Prerequisites

First, install the DROMA.Set package:

```r
# Install DROMA.Set (replace with actual installation method)
# devtools::install_github("mugpeng/DROMA_Set")
```

### Install DROMA.R

```r
# Install devtools if not already installed
if (!requireNamespace("devtools", quietly = TRUE)) {
  install.packages("devtools")
}

# Install DROMA.R from GitHub
devtools::install_github("mugpeng/DROMA_R")
```

## Quick Start

### 1. Load Required Packages

```r
library(DROMA.Set)  # For data management
library(DROMA.R)    # For analysis functions
```

### 2. Create DromaSet Objects

```r
# Connect to DROMA database
connectDROMADatabase("path/to/your/droma.sqlite")

# Create a single DromaSet for one project
gCSI <- createDromaSetFromDatabase("gCSI", "path/to/droma.sqlite")

# Create a MultiDromaSet for multiple projects
multi_set <- createMultiDromaSetFromDatabase(
    project_names = c("gCSI", "CCLE"),
    db_path = "path/to/droma.sqlite"
)
```

### 3. Analyze Drug-Omics Associations

```r
# Single project analysis
result <- analyzeDrugOmicPair(
  gCSI,
  select_omics_type = "mRNA",
  select_omics = "ABCB1",
  select_drugs = "Paclitaxel",
  data_type = "all",
  tumor_type = "all"
)

# Multi-project analysis
multi_result <- analyzeDrugOmicPair(
  multi_set,
  select_omics_type = "mRNA",
  select_omics = "ABCB1",
  select_drugs = "Paclitaxel",
  overlap_only = FALSE
)

# Display results
print(result$meta)
plot(result$plot)
```

### 4. Batch Feature Analysis

```r
# Find genes associated with drug response
batch_results <- batchFindSignificantFeatures(
  multi_set,
  feature1_type = "drug",
  feature1_name = "Paclitaxel",
  feature2_type = "mRNA",
  overlap_only = FALSE
)

# Create volcano plot
volcano_plot <- plotMetaVolcano(batch_results, es_t = 0.3, P_t = 0.05)
print(volcano_plot)
```

## Core Functions

### Analysis Functions
- **`analyzeDrugOmicPair()`**: Analyze association between drug response and omics feature
- **`batchFindSignificantFeatures()`**: Batch analysis of multiple features
- **`analyzeContinuousDrugOmic()`**: Meta-analysis for continuous data
- **`analyzeDiscreteDrugOmic()`**: Meta-analysis for discrete data

### Data Loading Functions (Z-score Normalized by Default)
- **`loadMolecularProfilesNormalized()`**: Load molecular profiles with z-score normalization (default: TRUE)
- **`loadTreatmentResponseNormalized()`**: Load treatment response data with z-score normalization (default: TRUE)
- **`loadMultiProjectMolecularProfilesNormalized()`**: Load multi-project molecular profiles with normalization
- **`loadMultiProjectTreatmentResponseNormalized()`**: Load multi-project treatment response with normalization
- **`applyZscoreNormalization()`**: Apply z-score normalization to existing data
- **`isZscoreNormalized()`**: Check if data has been z-score normalized

### Data Pairing Functions
- **`pairDrugOmic()`**: Pair continuous drug and omics data
- **`pairDiscreteDrugOmic()`**: Pair discrete omics with drug data
- **`pairContinuousFeatures()`**: Pair continuous feature data
- **`pairDiscreteFeatures()`**: Pair discrete with continuous features

### Visualization Functions
- **`createForestPlot()`**: Create forest plots for meta-analysis results
- **`plotMetaVolcano()`**: Create volcano plots for batch analysis results
- **`plotContinuousDrugOmic()`**: Scatter plots for continuous associations
- **`plotDiscreteDrugOmic()`**: Box plots for discrete associations

### Utility Functions
- **`bright_palette_26`**: Pre-defined palette of 26 distinct colors
- **`formatTime()`**: Format time durations
- **`estimateTimeRemaining()`**: Estimate remaining processing time

### Data Processing Functions
- **`processDrugData()`**: Process drug sensitivity data using DromaSet objects
- **`annotateDrugData()`**: Add sample annotations to drug sensitivity data (now with database loading support)
- **`getDrugSensitivityData()`**: Wrapper for processing and annotating drug data

## Examples

### Example 1: Loading Data with Z-score Normalization

```r
# Load required packages
library(DROMA.Set)
library(DROMA.R)

# Create DromaSet
gCSI <- createDromaSetFromDatabase("gCSI", "path/to/droma.sqlite")

# Load mRNA data with z-score normalization (default)
mrna_normalized <- loadMolecularProfilesNormalized(
  gCSI,
  molecular_type = "mRNA",
  features = "ABCB1"
)

# Load without normalization
mrna_raw <- loadMolecularProfilesNormalized(
  gCSI,
  molecular_type = "mRNA",
  features = "ABCB1",
  zscore = FALSE
)

# Check if data is normalized
cat("Normalized:", isZscoreNormalized(mrna_normalized))
cat("Raw:", isZscoreNormalized(mrna_raw))

# Load drug data with normalization
drug_normalized <- loadTreatmentResponseNormalized(
  gCSI,
  drugs = "Paclitaxel"
)
```

### Example 2: Multi-Project Normalized Loading

```r
# Create MultiDromaSet
multi_set <- createMultiDromaSetFromDatabase(c("gCSI", "CCLE"))

# Load normalized data across projects
multi_mrna <- loadMultiProjectMolecularProfilesNormalized(
  multi_set,
  molecular_type = "mRNA",
  features = "ABCB1",
  overlap_only = FALSE
)

# Load normalized drug data across projects
multi_drugs <- loadMultiProjectTreatmentResponseNormalized(
  multi_set,
  drugs = "Paclitaxel",
  overlap_only = FALSE
)

# Check normalization status for each project
for (project in names(multi_mrna)) {
  cat(project, "normalized:", isZscoreNormalized(multi_mrna[[project]]), "\n")
}
```

### Example 3: Single Project Analysis

```r
# Load required packages
library(DROMA.Set)
library(DROMA.R)

# Create DromaSet
gCSI <- createDromaSetFromDatabase("gCSI", "path/to/droma.sqlite")

# Analyze Paclitaxel vs ABCB1 expression
result <- analyzeDrugOmicPair(
  gCSI,
  select_omics_type = "mRNA",
  select_omics = "ABCB1",
  select_drugs = "Paclitaxel"
)

# View results
print(result$meta)
plot(result$plot)
```

### Example 4: Multi-Project Meta-Analysis

```r
# Create MultiDromaSet
multi_set <- createMultiDromaSetFromDatabase(c("gCSI", "CCLE"))

# Analyze across projects with overlapping samples
result <- analyzeDrugOmicPair(
  multi_set,
  select_omics_type = "mutation_gene",
  select_omics = "TP53",
  select_drugs = "Cisplatin",
  overlap_only = FALSE
)

# Create forest plot
createForestPlot(result$meta)
```

### Example 5: Batch Analysis

```r
# Find all genes associated with Paclitaxel response
batch_results <- batchFindSignificantFeatures(
  multi_set,
  feature1_type = "drug",
  feature1_name = "Paclitaxel",
  feature2_type = "mRNA",
  cores = 4  # Use parallel processing
)

# Sort by significance
sorted_results <- batch_results[order(batch_results$p_value), ]
print(head(sorted_results, 10))

# Create volcano plot
volcano_plot <- plotMetaVolcano(batch_results)
print(volcano_plot)
```

## Data Types Supported

### Molecular Profiles
- **mRNA**: Gene expression data
- **cnv**: Copy number variation data
- **mutation_gene**: Gene-level mutation data
- **mutation_site**: Site-specific mutation data
- **fusion**: Gene fusion data
- **meth**: DNA methylation data
- **proteinrppa**: Reverse-phase protein array data
- **proteinms**: Mass spectrometry proteomics data

### Treatment Response
- **drug**: Drug sensitivity/response data

## Performance Tips

1. For large-scale batch analyses, use `cores > 1` to enable parallel processing
2. Consider setting `overlap_only = TRUE` with MultiDromaSet when you need comparable sample analyses across all datasets
3. Use the `db_path` parameter with `annotateDrugData()` or `getDrugSensitivityData()` to automatically load sample annotations from the database when needed
4. For visualization of large datasets, consider filtering to specific tumor types or data types

## Contributing

Contributions to DROMA.R are welcome! Please feel free to submit issues or pull requests on GitHub.

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Citation

If you use DROMA.R in your research, please cite:

```
Zhong, P. Y. (2024). DROMA.R: Drug Omics Association Analysis Extension for DROMA.Set. 
R package version 0.9.0. https://github.com/mugpeng/DROMA_R
```

## Contact

For questions and feedback, please contact Peng Yu Zhong at yc47680@um.edu.mo.

---

**DROMA.R** - Advanced drug-omics association analysis powered by DROMA.Set ðŸ§¬ðŸ’ŠðŸ“Š



================================================
FILE: .Rbuildignore
================================================
^.*\.Rproj$
^\.Rproj\.user$
^archive/
^data/
^sql_db/



================================================
FILE: examples/README.md
================================================
# DROMA.R Package Examples

This directory contains example scripts demonstrating how to use DROMA.R with DROMA.Set objects for drug-omics association analysis.

## Getting Started

Before running these examples, make sure you have both packages installed:

```r
# Install DROMA.Set first (replace with actual installation method)
# devtools::install_github("mugpeng/DROMA_Set")

# Install DROMA.R
# devtools::install_github("mugpeng/DROMA_R")

# Load the packages
library(DROMA.Set)  # For data management
library(DROMA.R)    # For analysis functions
```

## Available Examples

### Data Management with DROMA.Set

- `example_data_loading.R`: Demonstrates creating DromaSet and MultiDromaSet objects from databases
- `example_feature_selection.R`: Shows how to load and extract specific molecular profiles and treatment response data

### Drug-Omics Analysis with DROMA.R

- `example_drug_omics_pairing.R`: Demonstrates analyzing associations between drug sensitivity and omics features using DromaSet objects
- `example_drug_feature_analysis.R`: Shows drug data processing and visualization functions
- `example_batch_feature_analysis.R`: Demonstrates batch analysis to find features associated with drug response

## Running Examples

You can run the examples directly from R:

```r
# Ensure your working directory is set to the package root
source("examples/example_data_loading.R")
```

Or from the command line:

```bash
Rscript examples/example_data_loading.R
```

## Required Data

These examples require access to a DROMA SQLite database. The database should contain:

- Sample annotations (`sample_anno` table)
- Drug annotations (`drug_anno` table)
- Project-specific data tables (e.g., `gCSI_mRNA`, `CCLE_drug`, etc.)

## Example Workflow

A typical workflow with DROMA.R and DROMA.Set involves:

1. **Creating DromaSet objects** with `createDromaSetFromDatabase()` or `createMultiDromaSetFromDatabase()`
2. **Loading specific data** using `loadMolecularProfiles()` and `loadTreatmentResponse()` methods
3. **Analyzing relationships** between drugs and omics data with `analyzeDrugOmicPair()`
4. **Batch processing** multiple features with `batchFindSignificantFeatures()`
5. **Visualizing results** with the provided plotting functions

## Benefits of New Approach

1. **Better data management**: DromaSet objects encapsulate data and metadata
2. **Cross-project analysis**: MultiDromaSet enables seamless meta-analysis
3. **Efficient data loading**: Load only what you need, when you need it
4. **Sample filtering**: Built-in support for data type and tumor type filtering
5. **Overlap detection**: Automatic handling of overlapping samples across projects 


================================================
FILE: examples/example_batch_feature_analysis.R
================================================
#!/usr/bin/env Rscript

# Example script for DROMA.R package: Batch Feature Analysis with DromaSet Objects
# This example demonstrates how to perform batch analysis to find features associated with drug response using DromaSet objects

# Load required libraries
library(meta)
library(metafor)
library(effsize)
library(ggplot2)
library(dplyr)
library(DROMA.Set)  # For data management
library(DROMA.R)    # For analysis functions

# Setup: Create DromaSet Objects----

# Note: Replace with your actual database path
db_path <- "sql_db/droma.sqlite"

# Connect to DROMA database
connectDROMADatabase(db_path)

# Create DromaSet objects
cat("Creating DromaSet objects...\n")
gCSI <- createDromaSetFromDatabase("gCSI", db_path)

# Create a MultiDromaSet for cross-project analysis
multi_set <- createMultiDromaSetFromDatabase(
  project_names = c("gCSI", "CCLE"),
  db_path = db_path
)

cat("DromaSet objects created successfully!\n\n")

# Example 1: Find genes associated with Paclitaxel response using single project ----

cat("Example 1: Finding genes associated with Paclitaxel response using single DromaSet...\n")
# Note: Setting test_top_100=TRUE to limit analysis time for the example
# In real usage, you might want to use test_top_100=FALSE to test all features
batch_results_single <- batchFindSignificantFeatures(
  gCSI,
  feature1_type = "drug",
  feature1_name = "Paclitaxel",
  feature2_type = "cnv",
  data_type = "all",
  tumor_type = "all",
  test_top_100 = TRUE  # Use only top 100 features for this example
)

# Display top features
if (!is.null(batch_results_single) && nrow(batch_results_single) > 0) {
  cat("Top genes associated with Paclitaxel response (single project):\n")
  # Sort by p-value
  sorted_results <- batch_results_single[order(batch_results_single$p_value),]
  print(head(sorted_results, 10))

  # Create a volcano plot of results
  cat("\nCreating volcano plot for single project results...\n")
  volcano_plot_single <- plotMetaVolcano(batch_results_single, es_t = 0.3, P_t = 0.05)
  print(volcano_plot_single)
} else {
  cat("No significant results found for single project analysis\n")
}

# Example 2: Find genes associated with Paclitaxel response using multiple projects ----

cat("\nExample 2: Finding genes associated with Paclitaxel response using MultiDromaSet...\n")
batch_results_multi <- batchFindSignificantFeatures(
  multi_set,
  feature1_type = "drug",
  feature1_name = "Paclitaxel",
  feature2_type = "cnv",
  data_type = "all",
  tumor_type = "all",
  overlap_only = FALSE,
  test_top_100 = TRUE  # Use only top 100 features for this example
)

# Display top features
if (!is.null(batch_results_multi) && nrow(batch_results_multi) > 0) {
  cat("Top genes associated with Paclitaxel response (multi-project meta-analysis):\n")
  # Sort by p-value
  sorted_results_multi <- batch_results_multi[order(batch_results_multi$p_value),]
  print(head(sorted_results_multi, 10))

  # Create a volcano plot of results
  cat("\nCreating volcano plot for multi-project results...\n")
  volcano_plot_multi <- plotMetaVolcano(batch_results_multi, es_t = 0.3, P_t = 0.05,
                                       title = "Multi-Project Meta-Analysis")
  print(volcano_plot_multi)
} else {
  cat("No significant results found for multi-project analysis\n")
}

######################################
# Example 3: Find mutations associated with Paclitaxel response
######################################

cat("\nExample 3: Finding mutations associated with Paclitaxel response...\n")
mutation_results <- batchFindSignificantFeatures(
  multi_set,
  feature1_type = "drug",
  feature1_name = "Paclitaxel",
  feature2_type = "mutation_gene",
  data_type = "all",
  tumor_type = "all",
  overlap_only = FALSE,
  test_top_100 = TRUE  # Use only top 100 features for this example
)

# Display top mutations
if (!is.null(mutation_results) && nrow(mutation_results) > 0) {
  cat("Top mutations associated with Paclitaxel response:\n")
  # Sort by p-value
  sorted_mutations <- mutation_results[order(mutation_results$p_value),]
  print(head(sorted_mutations, 10))

  # Create a volcano plot for mutations
  cat("\nCreating volcano plot for mutation results...\n")
  volcano_plot_mut <- plotMetaVolcano(mutation_results, es_t = 0.3, P_t = 0.05,
                                     title = "Mutations Associated with Paclitaxel Response")
  print(volcano_plot_mut)
} else {
  cat("No significant mutation associations found\n")
}

######################################
# Example 4: Compare results between single and multi-project analyses
######################################

if (!is.null(batch_results_single) && !is.null(batch_results_multi) &&
    nrow(batch_results_single) > 0 && nrow(batch_results_multi) > 0) {

  cat("\nExample 4: Comparing single vs multi-project results...\n")

  # Find common genes
  common_genes <- intersect(batch_results_single$name, batch_results_multi$name)

  if (length(common_genes) > 0) {
    cat("Found", length(common_genes), "genes analyzed in both approaches\n")

    # Compare p-values for common genes
    single_pvals <- batch_results_single$p_value[match(common_genes, batch_results_single$name)]
    multi_pvals <- batch_results_multi$p_value[match(common_genes, batch_results_multi$name)]

    # Create comparison data frame
    comparison_df <- data.frame(
      gene = common_genes,
      single_project_pval = single_pvals,
      multi_project_pval = multi_pvals,
      stringsAsFactors = FALSE
    )

    # Show genes with improved significance in multi-project analysis
    improved_genes <- comparison_df[comparison_df$multi_project_pval < comparison_df$single_project_pval, ]
    if (nrow(improved_genes) > 0) {
      cat("Genes with improved significance in multi-project analysis:\n")
      print(head(improved_genes[order(improved_genes$multi_project_pval), ], 5))
    }
  } else {
    cat("No common genes found between single and multi-project analyses\n")
  }
}

######################################
# Example 5: Parallel processing example
######################################

cat("\nExample 5: Using parallel processing for faster analysis...\n")
cat("Note: This example shows how to use multiple cores for batch analysis\n")

# Example with parallel processing (uncomment to use)
# parallel_results <- batchFindSignificantFeatures(
#   multi_set,
#   feature1_type = "drug",
#   feature1_name = "Paclitaxel",
#   feature2_type = "mRNA",
#   data_type = "all",
#   tumor_type = "all",
#   overlap_only = FALSE,
#   cores = 4,  # Use 4 CPU cores
#   test_top_100 = TRUE
# )

cat("To use parallel processing, set cores > 1 in batchFindSignificantFeatures()\n")

cat("\nBatch feature analysis examples completed!\n")
cat("Key takeaways:\n")
cat("1. Use batchFindSignificantFeatures() with DromaSet objects for batch analysis\n")
cat("2. MultiDromaSet enables meta-analysis across multiple projects\n")
cat("3. Use plotMetaVolcano() to visualize batch analysis results\n")
cat("4. Set test_top_100=TRUE for faster testing, FALSE for comprehensive analysis\n")
cat("5. Use parallel processing (cores > 1) for large-scale analyses\n")
cat("6. Compare single vs multi-project results to assess consistency\n")



================================================
FILE: examples/example_drug_feature_analysis.R
================================================
#!/usr/bin/env Rscript

# Example script for DROMA.R package: Drug Feature Analysis with DromaSet Objects
# This example demonstrates drug data processing and visualization functions using DromaSet objects

# Load required libraries
library(dplyr)
library(ggplot2)
library(ggpubr)
library(DT)
library(htmltools)
library(patchwork)
library(DROMA.Set)  # For data management
library(DROMA.R)    # For analysis functions

######################################
# Setup: Create DromaSet Objects
######################################

# Note: Replace with your actual database path
db_path <- "sql_db/droma.sqlite"

# Connect to DROMA database
connectDROMADatabase(db_path)

# Create DromaSet objects
cat("Creating DromaSet objects...\n")
gCSI <- createDromaSetFromDatabase("gCSI", db_path)
CCLE <- createDromaSetFromDatabase("CCLE", db_path)

# Create a MultiDromaSet for cross-project analysis
multi_set <- createMultiDromaSetFromDatabase(
  project_names = c("gCSI", "CCLE"),
  db_path = db_path
)

cat("DromaSet objects created successfully!\n\n")

######################################
# Example 1: Basic Drug Data Processing
######################################

# Get processed drug data for Paclitaxel using DromaSet
cat("Example 1: Processing data for Paclitaxel using DromaSet\n")
paclitaxel_data <- processDrugData(
  gCSI,
  drug_name = "Paclitaxel",
  data_type = "all",
  tumor_type = "all"
)

# Display summary information
if (!is.null(paclitaxel_data)) {
  cat("Retrieved Paclitaxel data for", nrow(paclitaxel_data), "samples\n")
  cat("Data columns:", paste(colnames(paclitaxel_data), collapse = ", "), "\n")
  cat("Number of studies:", length(unique(paclitaxel_data$study)), "\n")
  cat("Studies:", paste(unique(paclitaxel_data$study), collapse = ", "), "\n\n")
} else {
  cat("No Paclitaxel data found\n\n")
}

######################################
# Example 2: Annotating Drug Data
######################################

# Annotate the drug data with sample information
cat("Example 2: Annotating Paclitaxel data with sample information\n")
if (!is.null(paclitaxel_data)) {
  cat("\nDemonstrating direct database loading of sample annotations:\n")
  annotated_data_db <- annotateDrugData(paclitaxel_data, db_path = db_path)

  # Display summaries with annotations
  if (!is.null(annotated_data_db) && "TumorType" %in% colnames(annotated_data_db)) {
    tumor_counts <- table(annotated_data_db$TumorType)
    cat("Tumor Types in the dataset:\n")
    print(tumor_counts)
  }

  if (!is.null(annotated_data_db) && "ModelType" %in% colnames(annotated_data_db)) {
    model_counts <- table(annotated_data_db$ModelType)
    cat("\nModel Types in the dataset:\n")
    print(model_counts)
  }
} else {
  cat("No data available for annotation\n")
}

######################################
# Example 3: Multi-Project Drug Data Processing
######################################

# Get processed drug data for Paclitaxel using MultiDromaSet
cat("\nExample 3: Processing data for Paclitaxel using MultiDromaSet\n")
multi_paclitaxel_data <- processDrugData(
  multi_set,
  drug_name = "Paclitaxel",
  data_type = "all",
  tumor_type = "all",
  overlap_only = FALSE
)

# Display summary information
if (!is.null(multi_paclitaxel_data)) {
  cat("Retrieved Paclitaxel data from multiple projects:", nrow(multi_paclitaxel_data), "samples\n")
  cat("Studies included:", paste(unique(multi_paclitaxel_data$study), collapse = ", "), "\n")
} else {
  cat("No multi-project Paclitaxel data found\n")
}

######################################
# Example 4: Formatters and Wrappers
######################################

# Format drug data as a datatable (for interactive use)
cat("\nExample 4: Using the drug data table formatter and wrappers\n")
cat("In an interactive R session, this would display a formatted datatable\n")

# Using the wrapper with database path for annotations
cat("Using getDrugSensitivityData with database path for annotations:\n")
drug_data_with_db <- getDrugSensitivityData(
  gCSI,
  drug_name = "Paclitaxel",
  data_type = "all",
  tumor_type = "all",
  include_annotations = TRUE,
  db_path = db_path
)

if (!is.null(drug_data_with_db)) {
  cat("Retrieved", nrow(drug_data_with_db), "samples with annotations\n\n")
} else {
  cat("No drug sensitivity data retrieved\n\n")
}

formatted_table <- formatDrugTable(drug_data_with_db, caption = "Paclitaxel sensitivity data with annotations")

######################################
# Example 5: Visualization Functions
######################################

cat("\nExample 5: Visualization Functions - Continuous and Categorical Comparisons\n")

# Check if we have the required annotations in the data
if (!is.null(drug_data_with_db)) {
  # Continuous comparison: Drug sensitivity vs Age
  if ("Age" %in% colnames(drug_data_with_db)) {
    cat("Creating continuous comparison: Paclitaxel sensitivity vs Age\n")

    # Filter out missing values
    age_data <- drug_data_with_db[!is.na(drug_data_with_db$Age), ]

    if (nrow(age_data) >= 10) {  # Need enough samples for meaningful visualization
      cat("Found", nrow(age_data), "samples with Age data\n")

      # In interactive session, this would display a scatter plot
      p_age_scatter <- plotContinuousComparison(age_data,
                                               cont_column = "Age",
                                               value_column = "zscore_value",
                                               value_label = "Paclitaxel Sensitivity")

      # In interactive session, this would display a boxplot with binned age groups
      p_age_boxplot <- plotContinuousGroups(age_data,
                                            cont_column = "Age",
                                            value_column = "zscore_value",
                                            value_label = "Paclitaxel Sensitivity",
                                            num_bins = 3)

      # In interactive session, this would display a combined plot
      p_age_combined <- createDrugComparisonPlot(age_data,
                                                comparison_var = "Age",
                                                value_column = "zscore_value",
                                                value_label = "Paclitaxel Sensitivity")

      cat("Visualizations would include:\n")
      cat("1. Scatter plot with Spearman correlation between Age and drug sensitivity\n")
      cat("2. Boxplot with Age grouped into bins to compare drug sensitivity\n")
      cat("3. Combined visualization with both plots\n")
    } else {
      cat("Not enough samples with Age data for visualization\n")
    }
  } else {
    cat("Age data not available in the annotations\n")
  }

  # Categorical comparison: Drug sensitivity vs TumorType
  if ("TumorType" %in% colnames(drug_data_with_db)) {
    cat("\nCreating categorical comparison: Paclitaxel sensitivity vs TumorType\n")

    # Count samples per tumor type
    tumor_counts <- table(drug_data_with_db$TumorType)
    valid_tumors <- names(tumor_counts)[tumor_counts >= 3]

    if (length(valid_tumors) >= 2) {
      # Filter data to include only valid tumor types
      tumor_data <- drug_data_with_db[drug_data_with_db$TumorType %in% valid_tumors, ]
      cat("Found", length(valid_tumors), "tumor types with sufficient samples:",
          paste(valid_tumors, collapse = ", "), "\n")

      # In interactive session, this would display a categorical boxplot
       p_tumor <- plotCategoryComparison(tumor_data,
                                       category_column = "TumorType",
                                       value_column = "zscore_value",
                                       value_label = "Paclitaxel Sensitivity")

      cat("Visualization would include a boxplot comparing drug sensitivity across tumor types\n")
      cat("with statistical test to determine significance of differences\n")
    } else {
      cat("Not enough tumor types with sufficient samples for comparison\n")
    }
  } else {
    cat("TumorType data not available in the annotations\n")
  }
} else {
  cat("No annotated drug data available for visualization\n")
}

cat("\nDrug feature analysis examples completed!\n")
cat("Key takeaways:\n")
cat("1. Use processDrugData() with DromaSet objects for drug data processing\n")
cat("2. Use getDrugSensitivityData() for comprehensive drug data retrieval\n")
cat("3. Use loadMolecularProfilesNormalized() to get omics data for visualization\n")
cat("4. Combine drug and omics data for correlation analysis\n")
cat("5. Use MultiDromaSet for cross-project comparisons\n")



================================================
FILE: examples/example_drug_omics_pairing.R
================================================
#!/usr/bin/env Rscript

# Example script for DROMA.R package: Drug-Omics Pairing Analysis with DromaSet Objects
# This example demonstrates how to analyze associations between drug sensitivity and omics features using DromaSet objects

# Load required libraries
library(DROMA.Set)  # For data management
library(DROMA.R)    # For analysis functions
library(ggplot2)
library(metafor)
library(meta)
library(effsize)
library(ggpubr)
library(patchwork)

# Setup: Create DromaSet Objects ----

# Note: Replace with your actual database path
# db_path <- "path/to/your/droma.sqlite"
db_path <- "sql_db/droma.sqlite"

# Connect to DROMA database
connectDROMADatabase(db_path)

# Create DromaSet objects
cat("Creating DromaSet objects...\n")
gCSI <- createDromaSetFromDatabase("gCSI", db_path)
CCLE <- createDromaSetFromDatabase("CCLE", db_path)

# Create a MultiDromaSet for cross-project analysis
multi_set <- createMultiDromaSetFromDatabase(
  project_names = c("gCSI", "CCLE"),
  db_path = db_path
)

cat("DromaSet objects created successfully!\n\n")

# Check available data types
cat("Available treatment responses in gCSI:\n")
available_drugs <- availableTreatmentResponses(gCSI)
print(available_drugs)

cat("\nAvailable molecular profiles in gCSI:\n")
available_omics <- availableMolecularProfiles(gCSI)
print(available_omics)

# Example 1: Analyze association between Paclitaxel and ABCB1 gene expression (single project) ----

cat("\nExample 1: Analyzing association between Paclitaxel and ABCB1 gene expression (single project)...\n")
result_single <- analyzeDrugOmicPair(
  gCSI,
  select_omics_type = "cnv",
  select_omics = "ABCB1",
  select_drugs = "Paclitaxel",
  data_type = "all",
  tumor_type = "all"
)

# Example 2: Analyze association between Paclitaxel and ABCB1 gene expression (multi-project) ----

cat("\nExample 2: Analyzing association between Paclitaxel and ABCB1 gene expression (multi-project)...\n")
result_multi <- analyzeDrugOmicPair(
  multi_set,
  select_omics_type = "mRNA",
  select_omics = "ABCB1",
  select_drugs = "Paclitaxel",
  data_type = "all",
  tumor_type = "all",
  overlap_only = FALSE
)

# Overlap
result_multi2 <- analyzeDrugOmicPair(
  multi_set,
  select_omics_type = "mRNA",
  select_omics = "ABCB1",
  select_drugs = "Paclitaxel",
  data_type = "all",
  tumor_type = "all",
  overlap_only = TRUE
)

# Display results
if (!is.null(result_multi) && !is.null(result_multi$meta)) {
  cat("Meta-analysis results for multi-project analysis:\n")
  print(result_multi$meta)

  # Create forest plot
  cat("Creating forest plot for multi-project analysis...\n")
  createForestPlot(result_multi$meta)

  # Display correlation plots
  if (!is.null(result_multi$plot)) {
    print(result_multi$plot)
  }
} else {
  cat("No significant results found for multi-project analysis\n")
}

# Example 3: Analyze association between Paclitaxel and TP53 mutation status ----

cat("\nExample 3: Analyzing association between Paclitaxel and TP53 mutation status...\n")
result_mut <- analyzeDrugOmicPair(
  multi_set,
  select_omics_type = "mutation_gene",
  select_omics = "TP53",
  select_drugs = "Paclitaxel",
  data_type = "all",
  tumor_type = "all",
  overlap_only = FALSE
)

# Display results
if (!is.null(result_mut) && !is.null(result_mut$meta)) {
  cat("Meta-analysis results for mutation association:\n")
  print(result_mut$meta)

  # Create forest plot
  cat("Creating forest plot for mutation analysis...\n")
  createForestPlot(result_mut$meta)

  # Display boxplots
  if (!is.null(result_mut$plot)) {
    print(result_mut$plot)
  }
} else {
  cat("No significant results found for mutation analysis\n")
}

# Example 4: Compare drug sensitivity across different data types ----

cat("\nExample 4: Analyzing Paclitaxel sensitivity across different data types...\n")

# Analyze cell lines only
result_cellline <- analyzeDrugOmicPair(
  multi_set,
  select_omics_type = "mRNA",
  select_omics = "ABCB1",
  select_drugs = "Paclitaxel",
  data_type = "CellLine",
  tumor_type = "all",
  overlap_only = FALSE
)

if (!is.null(result_cellline) && !is.null(result_cellline$meta)) {
  cat("Results for cell lines only:\n")
  print(result_cellline$meta)
} else {
  cat("No significant results for cell lines\n")
}

# Analyze PDX models only (if available)
result_pdx <- analyzeDrugOmicPair(
  multi_set,
  select_omics_type = "mRNA",
  select_omics = "ABCB1",
  select_drugs = "Paclitaxel",
  data_type = "PDX",
  tumor_type = "all",
  overlap_only = FALSE
)

if (!is.null(result_pdx) && !is.null(result_pdx$meta)) {
  cat("Results for PDX models only:\n")
  print(result_pdx$meta)
} else {
  cat("No significant results for PDX models\n")
}

# Example 5: Get drug sensitivity data for visualization ----

cat("\nExample 5: Retrieving drug sensitivity data for Paclitaxel...\n")
drug_data <- getDrugSensitivityData(
  multi_set,
  drug_name = "Paclitaxel",
  data_type = "all",
  tumor_type = "all",
  overlap_only = FALSE
)

# Display summary of retrieved data
if (!is.null(drug_data)) {
  cat("Number of samples with Paclitaxel sensitivity data:", nrow(drug_data), "\n")
  cat("Studies with Paclitaxel data:\n")
  print(table(drug_data$study))

  # Show data structure
  cat("\nData structure:\n")
  cat("Columns:", paste(colnames(drug_data), collapse = ", "), "\n")
  cat("First few rows:\n")
  print(head(drug_data, 3))
} else {
  cat("No drug sensitivity data retrieved\n")
}

# Example 6: Analyze drug-drug associations----

cat("\nExample 6: Analyzing association between two drugs (Paclitaxel vs Cisplatin)...\n")
drug_drug_result <- analyzeDrugOmicPair(
  multi_set,
  select_omics_type = "drug",
  select_omics = "Cisplatin",
  select_drugs = "Paclitaxel",
  data_type = "all",
  tumor_type = "all",
  overlap_only = FALSE
)

if (!is.null(drug_drug_result) && !is.null(drug_drug_result$meta)) {
  cat("Drug-drug association results:\n")
  print(drug_drug_result$meta)

  # Create forest plot
  cat("Creating forest plot for drug-drug association...\n")
  createForestPlot(drug_drug_result$meta)

  if (!is.null(drug_drug_result$plot)) {
    print(drug_drug_result$plot)
  }
} else {
  cat("No significant drug-drug association found\n")
}

# Example 7: Tumor type-specific analysis ----

cat("\nExample 7: Tumor type-specific analysis (breast cancer)...\n")
breast_result <- analyzeDrugOmicPair(
  multi_set,
  select_omics_type = "mRNA",
  select_omics = "ABCB1",
  select_drugs = "Paclitaxel",
  data_type = "all",
  tumor_type = "breast cancer",
  overlap_only = FALSE
)

if (!is.null(breast_result) && !is.null(breast_result$meta)) {
  cat("Results for breast cancer samples:\n")
  print(breast_result$meta)

  if (!is.null(breast_result$plot)) {
    print(breast_result$plot)
  }
} else {
  cat("No significant results for breast cancer samples\n")
}

# Example 8: Using different omics types ----

cat("\nExample 8: Analyzing different omics types with Paclitaxel...\n")

# CNV analysis
cnv_result <- analyzeDrugOmicPair(
  multi_set,
  select_omics_type = "cnv",
  select_omics = "ABCB1",
  select_drugs = "Paclitaxel",
  data_type = "all",
  tumor_type = "all",
  overlap_only = FALSE
)

if (!is.null(cnv_result) && !is.null(cnv_result$meta)) {
  cat("CNV analysis results:\n")
  print(cnv_result$meta)
} else {
  cat("No significant CNV associations found\n")
}

# Methylation analysis (if available)
meth_result <- analyzeDrugOmicPair(
  multi_set,
  select_omics_type = "meth",
  select_omics = "ABCB1",
  select_drugs = "Paclitaxel",
  data_type = "all",
  tumor_type = "all",
  overlap_only = FALSE
)

if (!is.null(meth_result) && !is.null(meth_result$meta)) {
  cat("Methylation analysis results:\n")
  print(meth_result$meta)
} else {
  cat("No significant methylation associations found\n")
}

# Example 9: Use create_plot_with_common_axes ----
plot_with_axis <- create_plot_with_common_axes(selected_obj()$plot,
                                               x_title = "Molecular State(mRNA expression or Mutation status)",
                                               y_title = "drug sensitivity (higher indicates resistance)")

# Summary ----
cat("\nDrug-omics pairing analysis examples completed!\n")
cat("Key takeaways:\n")
cat("1. Use analyzeDrugOmicPair() with DromaSet objects for drug-omics analysis\n")
cat("2. MultiDromaSet enables meta-analysis across multiple projects\n")
cat("3. Use createForestPlot() to visualize meta-analysis results\n")
cat("4. Filter by data_type and tumor_type for targeted analyses\n")
cat("5. Analyze different omics types (mRNA, mutations, CNV, methylation)\n")
cat("6. Compare drug-drug associations using the same framework\n")
cat("7. Use getDrugSensitivityData() for detailed drug sensitivity information\n")



================================================
FILE: examples/example_feature_selection.R
================================================
#!/usr/bin/env Rscript

# Example script for DROMA.R package: Feature Selection with DromaSet Objects
# This example demonstrates how to retrieve omics and drug data using DromaSet and MultiDromaSet objects

# Load required libraries
library(DROMA.Set)  # For data management
library(DROMA.R)    # For analysis functions
library(dplyr)

# Setup: Create DromaSet Objects ----

# Note: Replace with your actual database path
db_path <- "sql_db/droma.sqlite"

# Connect to DROMA database
connectDROMADatabase(db_path)

# Create individual DromaSet objects
cat("Creating DromaSet objects...\n")
gCSI <- createDromaSetFromDatabase("gCSI", db_path)
CCLE <- createDromaSetFromDatabase("CCLE", db_path)

# Create a MultiDromaSet for cross-project analysis
multi_set <- createMultiDromaSetFromDatabase(
  project_names = c("gCSI", "CCLE"),
  db_path = db_path
)

cat("DromaSet objects created successfully!\n")

# Basic Feature Selection Examples ----

# Example 1: Load drug data (Paclitaxel) from a single project
cat("\nExample 1: Loading drug data for Paclitaxel from gCSI\n")
paclitaxel_data <- loadTreatmentResponseNormalized(gCSI,
                                         drugs = "Paclitaxel",
                                         return_data = TRUE)

if (is.matrix(paclitaxel_data) && "Paclitaxel" %in% rownames(paclitaxel_data)) {
  drug_vector <- as.numeric(paclitaxel_data["Paclitaxel", ])
  names(drug_vector) <- colnames(paclitaxel_data)
  drug_vector <- drug_vector[!is.na(drug_vector)]
  cat(sprintf("Retrieved Paclitaxel data: %d samples\n", length(drug_vector)))
} else {
  cat("Paclitaxel not found in treatment response data\n")
}

# Example 2: Load mRNA data (ABCB1) from a single project
cat("\nExample 2: Loading mRNA data for ABCB1 from gCSI\n")
abcb1_data <- loadMolecularProfilesNormalized(gCSI,
                                    molecular_type = "mRNA",
                                    features = "ABCB1",
                                    return_data = TRUE)

if (is.matrix(abcb1_data) && "ABCB1" %in% rownames(abcb1_data)) {
  mrna_vector <- as.numeric(abcb1_data["ABCB1", ])
  names(mrna_vector) <- colnames(abcb1_data)
  mrna_vector <- mrna_vector[!is.na(mrna_vector)]
  cat(sprintf("Retrieved ABCB1 data: %d samples\n", length(mrna_vector)))
} else {
  cat("ABCB1 not found in mRNA data\n")
}

# Example 3: Load mutation data (TP53) from a single project
cat("\nExample 3: Loading mutation data for TP53 from gCSI\n")
tp53_data <- loadMolecularProfilesNormalized(gCSI,
                                   molecular_type = "mutation_gene",
                                   features = "TP53",
                                   return_data = TRUE)

if (is.data.frame(tp53_data) && "genes" %in% colnames(tp53_data)) {
  tp53_samples <- tp53_data$cells[tp53_data$genes == "TP53"]
  cat(sprintf("Retrieved TP53 mutation data: %d samples with mutations\n", length(tp53_samples)))
} else {
  cat("TP53 mutation data not found\n")
}

# Multi-Project Feature Selection ----

# Example 4: Load drug data across multiple projects
cat("\nExample 4: Loading Paclitaxel data across multiple projects\n")
multi_paclitaxel <- loadMultiProjectTreatmentResponseNormalized(multi_set,
                                                     drugs = "Paclitaxel")

cat("Retrieved Paclitaxel data from", length(multi_paclitaxel), "projects:\n")
for (project_name in names(multi_paclitaxel)) {
  if (is.matrix(multi_paclitaxel[[project_name]]) && "Paclitaxel" %in% rownames(multi_paclitaxel[[project_name]])) {
    drug_vector <- as.numeric(multi_paclitaxel[[project_name]]["Paclitaxel", ])
    drug_vector <- drug_vector[!is.na(drug_vector)]
    cat(sprintf("- %s: %d samples\n", project_name, length(drug_vector)))
  }
}

# Example 5: Load mRNA data across multiple projects
cat("\nExample 5: Loading ABCB1 mRNA data across multiple projects\n")
multi_abcb1 <- loadMultiProjectMolecularProfilesNormalized(multi_set,
                                                 molecular_type = "mRNA",
                                                 features = "ABCB1")

cat("Retrieved ABCB1 data from", length(multi_abcb1), "projects:\n")
for (project_name in names(multi_abcb1)) {
  if (is.matrix(multi_abcb1[[project_name]]) && "ABCB1" %in% rownames(multi_abcb1[[project_name]])) {
    mrna_vector <- as.numeric(multi_abcb1[[project_name]]["ABCB1", ])
    mrna_vector <- mrna_vector[!is.na(mrna_vector)]
    cat(sprintf("- %s: %d samples\n", project_name, length(mrna_vector)))
  }
}

# Filtering by Data Type and Tumor Type ----

# Example 6: Get Paclitaxel data only for cell lines
cat("\nExample 6: Loading Paclitaxel data only for cell lines\n")
paclitaxel_cellline <- loadTreatmentResponseNormalized(gCSI,
                                            drugs = "Paclitaxel",
                                            data_type = "CellLine",
                                            return_data = TRUE)

if (is.matrix(paclitaxel_cellline) && "Paclitaxel" %in% rownames(paclitaxel_cellline)) {
  drug_vector <- as.numeric(paclitaxel_cellline["Paclitaxel", ])
  drug_vector <- drug_vector[!is.na(drug_vector)]
  cat(sprintf("Retrieved Paclitaxel cell line data: %d samples\n", length(drug_vector)))
} else {
  cat("No Paclitaxel cell line data found\n")
}

# Example 7: Get ABCB1 data for a specific tumor type
cat("\nExample 7: Loading ABCB1 data for breast cancer\n")
abcb1_breast <- loadMolecularProfilesNormalized(gCSI,
                                     molecular_type = "mRNA",
                                     features = "ABCB1",
                                     tumor_type = "breast cancer",
                                     return_data = TRUE)

if (is.matrix(abcb1_breast) && "ABCB1" %in% rownames(abcb1_breast)) {
  mrna_vector <- as.numeric(abcb1_breast["ABCB1", ])
  mrna_vector <- mrna_vector[!is.na(mrna_vector)]
  cat(sprintf("Retrieved ABCB1 breast cancer data: %d samples\n", length(mrna_vector)))
} else {
  cat("No ABCB1 breast cancer data found\n")
}

# Using DROMA.R Functions with DromaSet Objects ----

# Example 8: Use processDrugData with DromaSet
cat("\nExample 8: Using processDrugData with DromaSet object\n")
drug_sensitivity_data <- processDrugData(
  gCSI,
  drug_name = "Paclitaxel",
  data_type = "all",
  tumor_type = "all"
)

if (!is.null(drug_sensitivity_data)) {
  cat(sprintf("Processed drug sensitivity data: %d samples\n", nrow(drug_sensitivity_data)))
  cat("Columns:", paste(colnames(drug_sensitivity_data), collapse = ", "), "\n")
} else {
  cat("No drug sensitivity data processed\n")
}

# Example 9: Use getDrugSensitivityData with MultiDromaSet
cat("\nExample 9: Using getDrugSensitivityData with MultiDromaSet object\n")
multi_drug_data <- getDrugSensitivityData(
  multi_set,
  drug_name = "Paclitaxel",
  data_type = "all",
  tumor_type = "all",
  overlap_only = FALSE,
  include_annotations = FALSE
)

if (!is.null(multi_drug_data)) {
  cat(sprintf("Retrieved drug sensitivity data from multiple projects: %d samples\n", nrow(multi_drug_data)))
  cat("Studies included:", paste(unique(multi_drug_data$study), collapse = ", "), "\n")
} else {
  cat("No multi-project drug sensitivity data retrieved\n")
}

# Error Handling Examples ----

# Example 10: Handle non-existent features gracefully
cat("\nExample 10: Handling non-existent features\n")
tryCatch({
  nonexistent_data <- loadTreatmentResponseNormalized(gCSI,
                                            drugs = "NonExistentDrug",
                                            return_data = TRUE)

  if (is.matrix(nonexistent_data) && "NonExistentDrug" %in% rownames(nonexistent_data)) {
    cat("Found non-existent drug (unexpected)\n")
  } else {
    cat("Non-existent drug not found in data (as expected)\n")
  }
}, error = function(e) {
  cat("Error caught:", conditionMessage(e), "\n")
})

# Example 11: Handle invalid molecular types
cat("\nExample 11: Handling invalid molecular types\n")
tryCatch({
  invalid_data <- loadMolecularProfilesNormalized(gCSI,
                                        molecular_type = "invalid_type",
                                        features = "ABCB1",
                                        return_data = TRUE)
}, error = function(e) {
  cat("Error caught (as expected):", conditionMessage(e), "\n")
})

cat("\nFeature selection examples completed!\n")
cat("Key takeaways:\n")
cat("1. Use createDromaSetFromDatabase() to create single project objects\n")
cat("2. Use createMultiDromaSetFromDatabase() for multi-project analysis\n")
cat("3. Use loadTreatmentResponseNormalized() for drug data\n")
cat("4. Use loadMolecularProfilesNormalized() for omics data\n")
cat("5. Use DROMA.R functions like processDrugData() with DromaSet objects\n")



================================================
FILE: examples/example_normalized_loading.R
================================================
#!/usr/bin/env Rscript

# Example script for DROMA.R package: Normalized Data Loading with DromaSet Objects
# This example demonstrates how to load data with automatic z-score normalization

# Load required libraries
library(DROMA.Set)  # For data management
library(DROMA.R)    # For analysis functions

######################################
# Setup: Create DromaSet Objects
######################################

# Note: Replace with your actual database path
db_path <- "path/to/your/droma.sqlite"

# Connect to DROMA database
connectDROMADatabase(db_path)

# Create DromaSet objects
cat("Creating DromaSet objects...\n")
gCSI <- createDromaSetFromDatabase("gCSI", db_path)

# Create a MultiDromaSet for cross-project analysis
multi_set <- createMultiDromaSetFromDatabase(
  project_names = c("gCSI", "CCLE"),
  db_path = db_path
)

cat("DromaSet objects created successfully!\n\n")

######################################
# Example 1: Load molecular profiles with z-score normalization (default)
######################################

cat("Example 1: Loading mRNA data with z-score normalization (default)\n")

# Load ABCB1 mRNA data with z-score normalization (default behavior)
abcb1_normalized <- loadMolecularProfilesNormalized(
  CCLE,
  molecular_type = "mRNA",
  features = "ABCB1"
)

if (!is.null(abcb1_normalized)) {
  cat("Loaded ABCB1 mRNA data with z-score normalization\n")
  cat("Data dimensions:", dim(abcb1_normalized), "\n")
  cat("Is normalized:", isZscoreNormalized(abcb1_normalized), "\n")
  cat("Sample of normalized values:", head(abcb1_normalized[1, ], 3), "\n\n")
} else {
  cat("No ABCB1 mRNA data found\n\n")
}

######################################
# Example 2: Load molecular profiles without z-score normalization
######################################

cat("Example 2: Loading mRNA data without z-score normalization\n")

# Load ABCB1 mRNA data without z-score normalization
abcb1_raw <- loadMolecularProfilesNormalized(
  gCSI,
  molecular_type = "mRNA",
  features = "ABCB1",
  zscore = FALSE
)

if (!is.null(abcb1_raw)) {
  cat("Loaded ABCB1 mRNA data without z-score normalization\n")
  cat("Data dimensions:", dim(abcb1_raw), "\n")
  cat("Is normalized:", isZscoreNormalized(abcb1_raw), "\n")
  cat("Sample of raw values:", head(abcb1_raw[1, ], 3), "\n\n")
} else {
  cat("No ABCB1 mRNA data found\n\n")
}

######################################
# Example 3: Compare normalized vs raw data
######################################

if (!is.null(abcb1_normalized) && !is.null(abcb1_raw)) {
  cat("Example 3: Comparing normalized vs raw data\n")

  # Extract values for the same samples
  common_samples <- intersect(colnames(abcb1_normalized), colnames(abcb1_raw))

  if (length(common_samples) > 0) {
    normalized_values <- abcb1_normalized[1, common_samples]
    raw_values <- abcb1_raw[1, common_samples]

    cat("Raw data statistics:\n")
    cat("  Mean:", round(mean(raw_values, na.rm = TRUE), 3), "\n")
    cat("  SD:", round(sd(raw_values, na.rm = TRUE), 3), "\n")
    cat("  Range:", round(range(raw_values, na.rm = TRUE), 3), "\n")

    cat("Normalized data statistics:\n")
    cat("  Mean:", round(mean(normalized_values, na.rm = TRUE), 3), "\n")
    cat("  SD:", round(sd(normalized_values, na.rm = TRUE), 3), "\n")
    cat("  Range:", round(range(normalized_values, na.rm = TRUE), 3), "\n\n")
  }
}

######################################
# Example 4: Load treatment response data with normalization
######################################

cat("Example 4: Loading treatment response data with z-score normalization\n")

# Load Paclitaxel drug data with z-score normalization (default)
paclitaxel_normalized <- loadTreatmentResponseNormalized(
  gCSI,
  drugs = "Paclitaxel"
)

if (!is.null(paclitaxel_normalized)) {
  cat("Loaded Paclitaxel data with z-score normalization\n")
  cat("Data dimensions:", dim(paclitaxel_normalized), "\n")
  cat("Is normalized:", isZscoreNormalized(paclitaxel_normalized), "\n")
  cat("Sample of normalized values:", head(paclitaxel_normalized[1, ], 3), "\n\n")
} else {
  cat("No Paclitaxel data found\n\n")
}

######################################
# Example 5: Multi-project loading with normalization
######################################

cat("Example 5: Loading multi-project data with z-score normalization\n")

# Load ABCB1 mRNA data across multiple projects with normalization
multi_abcb1_normalized <- loadMultiProjectMolecularProfilesNormalized(
  multi_set,
  molecular_type = "mRNA",
  features = "ABCB1",
  overlap_only = FALSE
)

if (!is.null(multi_abcb1_normalized) && length(multi_abcb1_normalized) > 0) {
  cat("Loaded ABCB1 data from", length(multi_abcb1_normalized), "projects with normalization\n")

  for (project_name in names(multi_abcb1_normalized)) {
    project_data <- multi_abcb1_normalized[[project_name]]
    if (!is.null(project_data)) {
      cat("  ", project_name, "- Dimensions:", dim(project_data),
          "- Normalized:", isZscoreNormalized(project_data), "\n")
    }
  }
  cat("\n")
} else {
  cat("No multi-project ABCB1 data found\n\n")
}

######################################
# Example 6: Multi-project treatment response with normalization
######################################

cat("Example 6: Loading multi-project treatment response with z-score normalization\n")

# Load Paclitaxel data across multiple projects with normalization
multi_paclitaxel_normalized <- loadMultiProjectTreatmentResponseNormalized(
  multi_set,
  drugs = "Paclitaxel",
  overlap_only = FALSE
)

if (!is.null(multi_paclitaxel_normalized) && length(multi_paclitaxel_normalized) > 0) {
  cat("Loaded Paclitaxel data from", length(multi_paclitaxel_normalized), "projects with normalization\n")

  for (project_name in names(multi_paclitaxel_normalized)) {
    project_data <- multi_paclitaxel_normalized[[project_name]]
    if (!is.null(project_data)) {
      cat("  ", project_name, "- Dimensions:", dim(project_data),
          "- Normalized:", isZscoreNormalized(project_data), "\n")
    }
  }
  cat("\n")
} else {
  cat("No multi-project Paclitaxel data found\n\n")
}

######################################
# Example 7: Apply normalization to existing data
######################################

cat("Example 7: Applying z-score normalization to existing data\n")

# Load raw data first
raw_mrna_data <- loadMolecularProfilesNormalized(
  gCSI,
  molecular_type = "mRNA",
  features = c("ABCB1", "TP53", "BRCA1"),
  zscore = FALSE
)

if (!is.null(raw_mrna_data)) {
  cat("Loaded raw mRNA data for multiple genes\n")
  cat("Original data - Normalized:", isZscoreNormalized(raw_mrna_data), "\n")

  # Apply normalization to existing data
  manually_normalized <- applyZscoreNormalization(raw_mrna_data)

  cat("After manual normalization - Normalized:", isZscoreNormalized(manually_normalized), "\n")

  # Compare statistics
  cat("Raw data mean (first gene):", round(mean(raw_mrna_data[1, ], na.rm = TRUE), 3), "\n")
  cat("Normalized data mean (first gene):", round(mean(manually_normalized[1, ], na.rm = TRUE), 3), "\n\n")
} else {
  cat("No mRNA data found for manual normalization example\n\n")
}

######################################
# Example 8: Handle discrete data types (mutations)
######################################

cat("Example 8: Attempting normalization on discrete data (mutations)\n")

# Try to load mutation data with normalization (should give warning)
tp53_mutations <- loadMolecularProfilesNormalized(
  gCSI,
  molecular_type = "mutation_gene",
  features = "TP53",
  zscore = TRUE  # This should trigger a warning
)

if (!is.null(tp53_mutations)) {
  cat("Loaded TP53 mutation data\n")
  cat("Data type:", class(tp53_mutations), "\n")
  cat("Is normalized:", isZscoreNormalized(tp53_mutations), "\n\n")
} else {
  cat("No TP53 mutation data found\n\n")
}

######################################
# Example 9: Load all features with normalization
######################################

cat("Example 9: Loading all mRNA features with z-score normalization\n")

# Load all mRNA features (this might take time with large datasets)
# In practice, you might want to limit this or use specific features
all_mrna_normalized <- loadMolecularProfilesNormalized(
  gCSI,
  molecular_type = "mRNA",
  # features = NULL means load all features
  zscore = TRUE
)

if (!is.null(all_mrna_normalized)) {
  cat("Loaded all mRNA features with normalization\n")
  cat("Data dimensions:", dim(all_mrna_normalized), "\n")
  cat("Is normalized:", isZscoreNormalized(all_mrna_normalized), "\n")
  cat("Sample gene names:", head(rownames(all_mrna_normalized), 3), "\n\n")
} else {
  cat("No mRNA data found\n\n")
}

######################################
# Example 10: Using normalized data in analysis
######################################

cat("Example 10: Using normalized data in drug-omics analysis\n")

# The existing analyzeDrugOmicPair function can work with normalized data
# by using the normalized loading functions internally or by passing pre-normalized data

if (!is.null(multi_abcb1_normalized) && !is.null(multi_paclitaxel_normalized)) {
  cat("Normalized data is ready for use in analyzeDrugOmicPair or other analysis functions\n")
  cat("The normalization ensures data is on comparable scales across projects\n")

  # Example of how this would integrate with existing analysis
  cat("Example usage: analyzeDrugOmicPair(multi_set, 'mRNA', 'ABCB1', 'Paclitaxel')\n")
  cat("(The analysis functions can be updated to use normalized loading internally)\n\n")
} else {
  cat("Normalized data not available for analysis example\n\n")
}

cat("Normalized data loading examples completed!\n")
cat("Key takeaways:\n")
cat("1. Use loadMolecularProfilesNormalized() for normalized molecular data\n")
cat("2. Use loadTreatmentResponseNormalized() for normalized drug response data\n")
cat("3. Use loadMultiProject*Normalized() for multi-project normalized data\n")
cat("4. Set zscore=FALSE to disable normalization when needed\n")
cat("5. Use isZscoreNormalized() to check if data has been normalized\n")
cat("6. Use applyZscoreNormalization() to normalize existing data\n")
cat("7. Z-score normalization is automatically skipped for discrete data types\n")
cat("8. Normalized data ensures comparable scales across different projects\n")




================================================
FILE: R/FuncBatchFeature.R
================================================
# meta calculation ----
#' Calculate meta-analysis for continuous vs continuous features
#' @param selected_pair List of paired data
#' @return Meta-analysis result object or NULL if insufficient data
#' @export
metaCalcConCon <- function(selected_pair){
  if(length(selected_pair) < 1) return(NULL)
  # test pairs one by one
  cal_list <- lapply(1:length(selected_pair), function(y){
    fea1_sel <- selected_pair[[y]][[1]]
    fea2_sel <- selected_pair[[y]][[2]]
    # Check for minimum length
    if(length(fea1_sel) < 3 || length(fea2_sel) < 3) return(NULL)
    options(warn = -1)
    cor_re <- tryCatch(
      cor.test(fea1_sel, fea2_sel,
               method = "spearman"),
      error = function(x){return(NULL)}
    )
    if(is.null(cor_re)) return(NULL)
    data.frame(
      p = cor_re$p.value,
      effect = cor_re$estimate,
      N = length(fea2_sel)
    )
  })
  cal_list <- cal_list[!sapply(cal_list, is.null)]
  if(length(cal_list) < 1) return(NULL)
  cal_re <- do.call(rbind, cal_list)
  cal_re$se <- sqrt((1 - cal_re$effect^2) / (cal_re$N - 2))
  cal_re$z <- 0.5 * log((1 + cal_re$effect) / (1 - cal_re$effect))  # Fisher's z
  cal_re$se_z <- 1 / sqrt(cal_re$N - 3)

  cal_meta_re <- tryCatch(
    suppressWarnings({metagen(TE = z, seTE = se_z, data = cal_re, sm = "Z",
                              control = list(maxiter = 2000,
                                             stepadj = 0.1,
                                             threshold = 0.000001)
    )}),
    error = function(x){return(NULL)}
  )
  cal_meta_re
}

#' Calculate meta-analysis for continuous vs discrete features
#' @param selected_pair List of paired data
#' @return Meta-analysis result object or NULL if insufficient data
#' @export
metaCalcConDis <- function(selected_pair){
  options(warn = -1)
  if(length(selected_pair) < 1) return(NULL)
  cal_list <- lapply(1:length(selected_pair), function(y){
    yes_drugs <- selected_pair[[y]][[1]]
    no_drugs <- selected_pair[[y]][[2]]

    # Check for minimum length
    if(length(yes_drugs) < 3 || length(no_drugs) < 3) return(NULL)
    wilcox_re <- tryCatch(
      wilcox.test(no_drugs, yes_drugs),
      error = function(x){return(NULL)}
    )
    if(is.null(wilcox_re)) return(NULL)

    cliff_delta <- tryCatch(
      cliff.delta(no_drugs, yes_drugs),
      error = function(x){return(NULL)}
    )
    if(is.null(cliff_delta)) return(NULL)

    data.frame(
      p = wilcox_re$p.value,
      effect = cliff_delta$estimate,
      N = length(yes_drugs) + length(no_drugs),
      n1 = length(yes_drugs),
      n2 = length(no_drugs)
    )
  })
  cal_list <- cal_list[!sapply(cal_list, is.null)]
  if(length(cal_list) < 1) return(NULL)
  cal_re <- do.call(rbind, cal_list)
  # Calculate standard error for Cliff's Delta
  cal_re$se <- sqrt((1 - cal_re$effect^2) * (cal_re$n1 + cal_re$n2 + 1) /
                      (12 * cal_re$n1 * cal_re$n2))
  cal_meta_re <- tryCatch(
    suppressWarnings({meta_result <- metagen(TE = effect,
                                             seTE = se,
                                             data = cal_re,
                                             control = list(maxiter = 2000,
                                                            stepadj = 0.1,
                                                            threshold = 0.000001),
                                             sm = "CMD",  # Custom Mean Difference (using Cliff's Delta)
    )
    }),
    error = function(x){return(NULL)}
  )
  cal_meta_re
}

#' Calculate meta-analysis for discrete vs discrete features
#' @param selected_pair List of paired data
#' @return Meta-analysis result object or NULL if insufficient data
#' @export
metaCalcDisDis <- function(selected_pair) {
  # Check if we have enough pairs for meta-analysis
  if(length(selected_pair) < 1) return(NULL)

  # Calculate statistics for each pair
  cal_list <- lapply(1:length(selected_pair), function(y) {
    cont_table <- selected_pair[[y]]$cont_table

    # Skip if any cell has too few observations (e.g., < 3)
    if(any(cont_table < 3)) return(NULL)

    # Calculate odds ratio and its standard error
    tryCatch({
      # Extract values from contingency table
      a <- cont_table[1,1] # yes-yes
      b <- cont_table[1,2] # yes-no
      c <- cont_table[2,1] # no-yes
      d <- cont_table[2,2] # no-no

      # Calculate log odds ratio and its standard error
      log_or <- log((a * d)/(b * c))
      se_log_or <- sqrt(1/a + 1/b + 1/c + 1/d)

      # Calculate Fisher's exact test p-value
      fisher_test <- fisher.test(cont_table)

      data.frame(
        log_or = log_or,
        se = se_log_or,
        p = fisher_test$p.value,
        N = sum(cont_table)
      )
    }, error = function(x) NULL)
  })

  # Remove NULL results and combine
  cal_list <- cal_list[!sapply(cal_list, is.null)]
  if(length(cal_list) < 1) return(NULL)

  cal_re <- do.call(rbind, cal_list)

  # Perform meta-analysis using random effects model
  cal_meta_re <- tryCatch(
    suppressWarnings({
      metagen(TE = log_or,
              seTE = se,
              data = cal_re,
              sm = "OR", # Specify odds ratio as summary measure
              control = list(maxiter = 2000,
                             stepadj = 0.1,
                             threshold = 0.000001)
      )
    }),
    error = function(x) NULL
  )

  cal_meta_re
}

# Utility Functions ----

#' Format seconds into a human-readable time string
#'
#' @description Converts seconds into a more readable time format (hours, minutes, seconds)
#' @param seconds Number of seconds
#' @return Formatted time string
#' @export
formatTime <- function(seconds) {
  if (seconds < 60) {
    return(sprintf("%d seconds", round(seconds)))
  } else if (seconds < 3600) {
    minutes <- floor(seconds / 60)
    remaining_seconds <- round(seconds %% 60)
    return(sprintf("%d minutes %d seconds", minutes, remaining_seconds))
  } else {
    hours <- floor(seconds / 3600)
    remaining_minutes <- floor((seconds %% 3600) / 60)
    return(sprintf("%d hours %d minutes", hours, remaining_minutes))
  }
}

#' Calculate estimated time remaining based on progress
#'
#' @description Estimates remaining time for a batch process based on current progress
#' @param done Number of items processed
#' @param total Total number of items
#' @param elapsed_time Time elapsed so far in seconds
#' @return Estimated time remaining in seconds
#' @export
estimateTimeRemaining <- function(done, total, elapsed_time) {
  if (done == 0) return(Inf)
  rate <- elapsed_time / done
  remaining <- total - done
  remaining * rate
}

# Pairing Functions ----

#' Pair continuous with continuous data
#'
#' @description Creates paired datasets of two continuous features
#' @param myOmics First feature data list
#' @param myDrugs Second feature data list
#' @return List of paired data
#' @export
pairContinuousFeatures <- function(myOmics, myDrugs){
  pair_list2 <- lapply(1:length(myOmics), function(x){
    omic_sel <- myOmics[[x]]
    pair_list <- lapply(1:length(myDrugs), function(y){
      drug_sel <- myDrugs[[y]]
      omic_sel <- na.omit(omic_sel); drug_sel <- na.omit(drug_sel)
      if(length(na.omit(omic_sel)) == 0 | length(na.omit(drug_sel)) == 0){ return(NULL) }
      intersected_cells <- intersect(names(omic_sel), names(drug_sel))
      if(length(intersected_cells) < 3){ return(NULL) }
      omic_sel <- omic_sel[match(intersected_cells, names(omic_sel))]
      drug_sel <- drug_sel[match(intersected_cells, names(drug_sel))]
      list(omic_sel, drug_sel)
    })
    names(pair_list) <- paste0(names(myOmics)[x], "_",
                               names(myDrugs))
    pair_list
  })
  pair_list2 <- unlist(pair_list2, recursive = F)
  pair_list2 <- pair_list2[!sapply(pair_list2, is.null)]
  pair_list2
}

#' Pair discrete with continuous data
#'
#' @description Creates paired datasets of discrete and continuous features
#' @param myOmics Discrete feature data list (samples with feature present)
#' @param myDrugs Continuous feature data list (numeric values)
#' @return List of paired data with yes/no groups
#' @export
pairDiscreteFeatures <- function(myOmics, myDrugs){
  pair_list2 <- lapply(1:length(myOmics), function(x){
    omic_sel <- myOmics[[x]]
    pair_list <- lapply(1:length(myDrugs), function(y){
      drug_sel <- myDrugs[[y]]
      yes_drugs <- na.omit(drug_sel[names(drug_sel) %in% omic_sel])
      no_drugs <- na.omit(drug_sel[!names(drug_sel) %in% omic_sel])
      if(length(yes_drugs) < 3 | length(no_drugs) < 3){
        return(NULL)
      }
      list(yes = yes_drugs,
           no = no_drugs)
    })
    names(pair_list) <- paste0(names(myOmics)[x], "_",
                               names(myDrugs))
    pair_list
  })
  pair_list2 <- unlist(pair_list2, recursive = F)
  pair_list2 <- pair_list2[!sapply(pair_list2, is.null)]
  return(pair_list2)
}

#' Pair discrete with discrete data
#'
#' @description Creates paired datasets of two discrete features with contingency tables
#' @param my_feas1 First discrete feature data list (samples with feature present)
#' @param my_feas2 Second discrete feature data list (samples with feature present)
#' @param feature1_type Type of first feature
#' @param feature2_type Type of second feature
#' @param samples_search Reference data for all cells
#' @return List of paired data with contingency tables
#' @export
pairDiscreteDiscrete <- function(my_feas1, my_feas2,
                                feature1_type, feature2_type,
                                samples_search) {
  # Create pairs list across all features in dataset 1
  pair_list3 <- lapply(1:length(my_feas1), function(x) {
    fea1_sel <- my_feas1[[x]]
    # For each feature in dataset 1, compare with all features in dataset 2
    pair_list <- lapply(1:length(my_feas2), function(y) {
      fea2_sel <- my_feas2[[y]]
      # Skip if either feature has no data
      if (length(fea1_sel) == 0 || length(fea2_sel) == 0) {
        return(NULL)
      }

      # Get relevant cell/sample universe
      cells_search_sel <- samples_search[samples_search$type %in% c(feature1_type, feature2_type) &
                                         samples_search$datasets %in% c(names(my_feas1)[x], names(my_feas2)[y]),]
      all_cells <- unique(cells_search_sel$cells)

      # Create 2x2 contingency table
      yes_yes <- length(intersect(fea1_sel, fea2_sel))
      yes_no <- length(fea1_sel) - yes_yes
      no_yes <- length(fea2_sel) - yes_yes
      no_no <- length(all_cells) - (yes_yes + yes_no + no_yes)

      # Skip if any cell count is too low or negative (invalid)
      if (any(c(yes_yes, yes_no, no_yes, no_no) < 3)) {
        return(NULL)
      }

      # Create contingency table
      cont_table <- matrix(
        c(yes_yes, yes_no,
          no_yes, no_no),
        nrow = 2,
        dimnames = list(
          Feature1 = c("Yes", "No"),
          Feature2 = c("Yes", "No")
        )
      )

      list(
        "cont_table" = cont_table
      )
    })

    names(pair_list) <- paste0(names(my_feas1)[x], "_",
                               names(my_feas2))
    pair_list
  })

  # Flatten list and remove NULL entries
  pair_list3 <- unlist(pair_list3, recursive = FALSE)
  pair_list3 <- pair_list3[!sapply(pair_list3, is.null)]

  return(pair_list3)
}

# Plot ----
#' Create a volcano plot from meta-analysis results
#'
#' @param meta_df Data frame containing meta-analysis results with columns:
#'                effect_size, p_value, and name
#' @param es_t Effect size threshold to consider significant
#' @param P_t P-value threshold to consider significant
#' @param label Whether to add labels to top points (TRUE/FALSE)
#' @param top_label_each Number of top points in each direction to label
#' @param label_size Size of text labels
#' @param point_size Size of points
#' @param point_alpha Alpha transparency of points
#' @param title Plot title (NULL for no title)
#' @param p_adj_method Method for p-value adjustment ("none", "BH", "bonferroni")
#' @param custom_colors Custom color vector for Up, NS, Down (NULL for defaults)
#' @return ggplot object with volcano plot
#' @export
plotMetaVolcano <- function(meta_df,
                            es_t = .4,
                            P_t = .001,
                            label = TRUE,
                            top_label_each = 5,
                            label_size = 5,
                            point_size = 2.5,
                            point_alpha = 0.6,
                            title = NULL,
                            p_adj_method = "none",
                            custom_colors = NULL) {

  # Input validation
  if(!is.data.frame(meta_df)) stop("meta_df must be a data frame")
  if(!all(c("effect_size", "p_value", "name") %in% colnames(meta_df))) {
    stop("meta_df must contain columns: effect_size, p_value, and name")
  }

  # Handle p-value adjustment if requested
  if(p_adj_method != "none") {
    meta_df$p_value <- p.adjust(meta_df$p_value, method = p_adj_method)
  }

  # Default colors
  if(is.null(custom_colors)) {
    custom_colors <- c("Down" = "#44bce4", "NS" = "grey", "Up" = "#fc7474")
  }

  # Group the points based on thresholds
  meta_df$group <- dplyr::case_when(
    meta_df$effect_size > es_t & meta_df$p_value < P_t ~ "Up",
    meta_df$effect_size < -es_t & meta_df$p_value < P_t ~ "Down",
    TRUE ~ "NS"
  )

  # Count significant findings
  sig_counts <- table(meta_df$group)
  sig_text <- paste0(
    "Up: ", sum(meta_df$group == "Up"), ", ",
    "Down: ", sum(meta_df$group == "Down"), ", ",
    "Total: ", nrow(meta_df)
  )

  # Basic volcano plot
  p <- ggplot(data = meta_df,
              aes(x = effect_size,
                  y = -log10(p_value))) +
    geom_point(size = point_size, alpha = point_alpha,
               aes(color = group)) +
    theme_bw() +
    theme(
      legend.position = "none",
      title = element_text(size = 15, face = "bold"),
      axis.title = element_text(size = 15, colour = "black"),
      axis.text = element_text(size = 15, color = "black"),
      legend.title = element_text(size = 15, colour = "black"),
      legend.text = element_text(size = 15),
      text = element_text(colour = "black"),
      axis.title.x = element_text(colour = "black")
    ) +
    ylab("-log10(Pvalue)") +
    xlab("Effect Size") +
    scale_color_manual(values = custom_colors) +
    geom_vline(xintercept = c(-es_t, es_t), lty = 4, col = "black", lwd = 0.5) +
    geom_hline(yintercept = -log10(P_t), lty = 4, col = "black", lwd = 0.5) +
    annotate("text", x = min(meta_df$effect_size, na.rm = TRUE) * 0.8,
             y = max(-log10(meta_df$p_value), na.rm = TRUE) * 0.9,
             label = sig_text, hjust = 0, size = 5)

  # Add title if provided
  if(!is.null(title)) {
    p <- p + ggtitle(title)
  }

  # Add labels if requested
  if(label) {
    meta_df2 <- meta_df[meta_df$group != "NS",]

    # Skip labeling if there are no significant points
    if(nrow(meta_df2) > 0) {
      # Get top points to label
      low_indices <- head(order(meta_df2$effect_size), min(top_label_each, nrow(meta_df2)))
      high_indices <- tail(order(meta_df2$effect_size), min(top_label_each, nrow(meta_df2)))
      forlabel_names <- c(meta_df2$name[low_indices], meta_df2$name[high_indices])
      forlabel_df <- meta_df2[meta_df2$name %in% forlabel_names,]

      p <- p +
        geom_point(size = point_size + 0.5, shape = 1, data = forlabel_df) +
        ggrepel::geom_text_repel(
          data = forlabel_df,
          aes(label = name),
          size = label_size,
          color = "black",
          box.padding = 0.5,
          point.padding = 0.3,
          force = 5,
          max.overlaps = 20
        )
    }
  }

  p
}

# Main function----
#' Batch analysis to find significant features associated with a reference feature using DromaSet objects
#'
#' @description Performs batch analysis to identify features significantly associated with a reference feature using DromaSet or MultiDromaSet objects
#' @param dromaset_object Either a DromaSet or MultiDromaSet object
#' @param feature1_type Type of the reference feature (e.g., "drug", "mRNA")
#' @param feature1_name Name of the reference feature
#' @param feature2_type Type of features to test against (e.g., "mRNA", "mutation_gene")
#' @param data_type Filter by data type ("all", "CellLine", "PDO", "PDC", "PDX")
#' @param tumor_type Filter by tumor type ("all" or specific tumor types)
#' @param overlap_only For MultiDromaSet, whether to use only overlapping samples (default: FALSE)
#' @param cores Number of CPU cores to use for parallel processing
#' @param progress_callback Optional callback function for progress updates
#' @param test_top_100 Logical, whether to test only top 100 features (for debugging)
#' @return Data frame with meta-analysis results (p_value, effect_size, name)
#' @export
#' @examples
#' \dontrun{
#' # Using DromaSet
#' gCSI <- createDromaSetFromDatabase("gCSI", "path/to/droma.sqlite")
#' results <- batchFindSignificantFeatures(gCSI, "drug", "Paclitaxel", "mRNA")
#'
#' # Using MultiDromaSet
#' multi_set <- createMultiDromaSetFromDatabase(c("gCSI", "CCLE"), "path/to/droma.sqlite")
#' results <- batchFindSignificantFeatures(multi_set, "drug", "Paclitaxel", "mRNA")
#' }
batchFindSignificantFeatures <- function(dromaset_object,
                                      feature1_type,
                                      feature1_name,
                                      feature2_type,
                                      data_type = "all",
                                      tumor_type = "all",
                                      overlap_only = FALSE,
                                      cores = 1,
                                      progress_callback = NULL,
                                      test_top_100 = FALSE
) {
  # Validate input object
  if (!inherits(dromaset_object, c("DromaSet", "MultiDromaSet"))) {
    stop("Input must be a DromaSet or MultiDromaSet object from DROMA.Set package")
  }

  # Validate inputs
  valid_feature_types <- c("mRNA", "cnv", "meth", "proteinrppa", "proteinms",
                           "drug", "mutation_gene", "mutation_site", "fusion")

  if(!all(c(feature1_type, feature2_type) %in% valid_feature_types)) {
    stop(paste0("The selected feature type doesn't exist. Please choose from: ",
                paste(valid_feature_types, collapse = ", ")))
  }

  valid_data_types <- c("all", "CellLine", "PDO", "PDC", "PDX")
  if(!data_type %in% valid_data_types) {
    stop(paste0("Invalid data_type. Please choose from: ",
                paste(valid_data_types, collapse = ", ")))
  }

  # Track timing for progress updates
  start_time <- Sys.time()

  # Determine feature types
  continuous_types <- c("drug", "cnv", "proteinrppa",
                        "proteinms", "meth", "mRNA")
  is_continuous1 <- feature1_type %in% continuous_types
  is_continuous2 <- feature2_type %in% continuous_types

  # Get selected specific feature1 data
  if (inherits(dromaset_object, "DromaSet")) {
    # Single DromaSet
    if (feature1_type %in% c("drug")) {
      feature1_data <- loadTreatmentResponseNormalized(dromaset_object,
                                           drugs = feature1_name,
                                           data_type = data_type,
                                           tumor_type = tumor_type,
                                           return_data = TRUE)

      if (is.matrix(feature1_data) && feature1_name %in% rownames(feature1_data)) {
        feature1_vector <- as.numeric(feature1_data[feature1_name, ])
        names(feature1_vector) <- colnames(feature1_data)
        selected_feas1 <- list()
        selected_feas1[[dromaset_object@name]] <- feature1_vector[!is.na(feature1_vector)]
      } else {
        stop("Feature1 not found in treatment response data")
      }
    } else {
      # Molecular profile data
      feature1_data <- loadMolecularProfilesNormalized(dromaset_object,
                                           molecular_type = feature1_type,
                                           data_type = data_type,
                                           tumor_type = tumor_type,
                                           return_data = TRUE)

      if (is_continuous1) {
        # Continuous data
        if (is.matrix(feature1_data) && feature1_name %in% rownames(feature1_data)) {
          feature1_vector <- as.numeric(feature1_data[feature1_name, ])
          names(feature1_vector) <- colnames(feature1_data)
          selected_feas1 <- list()
          selected_feas1[[dromaset_object@name]] <- feature1_vector[!is.na(feature1_vector)]
        } else {
          stop("Feature1 not found in molecular profile data")
        }
      } else {
        # Discrete data
        if (is.data.frame(feature1_data)) {
          if ("cells" %in% colnames(feature1_data)) {
            sample_ids <- feature1_data$cells[feature1_data$genes == feature1_name]
          } else if ("samples" %in% colnames(feature1_data)) {
            sample_ids <- feature1_data$samples[feature1_data$genes == feature1_name]
          } else {
            sample_ids <- character(0)
          }
          selected_feas1 <- list()
          selected_feas1[[dromaset_object@name]] <- sample_ids
        } else {
          stop("Feature1 not found in molecular profile data")
        }
      }
    }
  } else {
    # MultiDromaSet
    if (feature1_type %in% c("drug")) {
      feature1_data <- loadMultiProjectTreatmentResponseNormalized(dromaset_object,
                                                        drugs = feature1_name,
                                                        overlap_only = overlap_only,
                                                        data_type = data_type,
                                                        tumor_type = tumor_type)

      selected_feas1 <- lapply(feature1_data, function(drug_matrix) {
        if (is.matrix(drug_matrix) && feature1_name %in% rownames(drug_matrix)) {
          drug_vector <- as.numeric(drug_matrix[feature1_name, ])
          names(drug_vector) <- colnames(drug_matrix)
          return(drug_vector[!is.na(drug_vector)])
        }
        return(NULL)
      })
    } else {
      # Molecular profile data
      feature1_data <- loadMultiProjectMolecularProfilesNormalized(dromaset_object,
                                                        molecular_type = feature1_type,
                                                        data_type = data_type,
                                                        tumor_type = tumor_type)

      if (is_continuous1) {
        # Continuous data
        selected_feas1 <- lapply(feature1_data, function(omics_matrix) {
          if (is.matrix(omics_matrix) && feature1_name %in% rownames(omics_matrix)) {
            omics_vector <- as.numeric(omics_matrix[feature1_name, ])
            names(omics_vector) <- colnames(omics_matrix)
            return(omics_vector[!is.na(omics_vector)])
          }
          return(NULL)
        })
      } else {
        # Discrete data
        selected_feas1 <- lapply(feature1_data, function(omics_df) {
          if (is.data.frame(omics_df)) {
            if ("cells" %in% colnames(omics_df)) {
              sample_ids <- omics_df$cells[omics_df$genes == feature1_name]
            } else if ("samples" %in% colnames(omics_df)) {
              sample_ids <- omics_df$samples[omics_df$genes == feature1_name]
            } else {
              sample_ids <- character(0)
            }
            return(sample_ids)
          }
          return(NULL)
        })
      }
    }

    # Remove NULL entries
    selected_feas1 <- selected_feas1[!sapply(selected_feas1, is.null)]
  }

  if(is.null(selected_feas1) || length(selected_feas1) == 0) {
    stop("No data available for the selected feature 1.")
  }

  # Filter selected_feas1 to ensure each dataset has at least 3 samples
  selected_feas1 <- lapply(selected_feas1, function(dataset) {
    # Remove NA values
    dataset <- na.omit(dataset)
    # Check if the dataset has at least 3 samples after NA removal
    if (length(dataset) < 3) {
      return(NULL)
    } else {
      return(dataset)
    }
  })

  # Remove NULL entries
  selected_feas1 <- selected_feas1[!sapply(selected_feas1, is.null)]

  # Check if any data remains after filtering
  if(length(selected_feas1) == 0) {
    stop(paste0("No sufficient data available for feature '", feature1_name,
                "' of type '", feature1_type, "'. Each dataset needs at least 3 samples. ",
                "Please try with a different feature."))
  }

  # Get list of features to test from the dromaset object
  feature2_list <- NULL
  if (inherits(dromaset_object, "DromaSet")) {
    if (feature2_type %in% c("drug")) {
      # Get available drugs
      available_features <- availableTreatmentResponses(dromaset_object)
      if ("drug" %in% available_features) {
        # Load all drugs to get feature names
        all_drug_data <- loadTreatmentResponseNormalized(dromaset_object, return_data = TRUE)
        if (is.matrix(all_drug_data)) {
          feature2_list <- rownames(all_drug_data)
        }
      }
    } else {
      # Get available molecular profiles
      available_profiles <- availableMolecularProfiles(dromaset_object)
      if (feature2_type %in% available_profiles) {
        # Load all features to get feature names
        all_omics_data <- loadMolecularProfilesNormalized(dromaset_object,
                                               molecular_type = feature2_type,
                                               data_type = data_type,
                                               tumor_type = tumor_type,
                                               return_data = TRUE)
        if (is.matrix(all_omics_data)) {
          feature2_list <- rownames(all_omics_data)
        } else if (is.data.frame(all_omics_data) && "genes" %in% colnames(all_omics_data)) {
          feature2_list <- unique(all_omics_data$genes)
        }
      }
    }
  } else {
    # MultiDromaSet - get features from first project that has the data
    for (project_name in names(dromaset_object@DromaSets)) {
      dromaset <- dromaset_object@DromaSets[[project_name]]

      if (feature2_type %in% c("drug")) {
        available_features <- availableTreatmentResponses(dromaset)
        if ("drug" %in% available_features) {
          all_drug_data <- loadTreatmentResponseNormalized(dromaset, return_data = TRUE)
          if (is.matrix(all_drug_data)) {
            feature2_list <- rownames(all_drug_data)
            break
          }
        }
      } else {
        available_profiles <- availableMolecularProfiles(dromaset)
        if (feature2_type %in% available_profiles) {
          all_omics_data <- loadMolecularProfilesNormalized(dromaset,
                                                 molecular_type = feature2_type,
                                                 data_type = data_type,
                                                 tumor_type = tumor_type,
                                                 return_data = TRUE)
          if (is.matrix(all_omics_data)) {
            feature2_list <- rownames(all_omics_data)
            break
          } else if (is.data.frame(all_omics_data) && "genes" %in% colnames(all_omics_data)) {
            feature2_list <- unique(all_omics_data$genes)
            break
          }
        }
      }
    }
  }

  if (is.null(feature2_list)) {
    stop("Could not find available features for feature2_type: ", feature2_type)
  }

  # Apply test_top_100 filter
  if(test_top_100 && length(feature2_list) > 100){
    feature2_list <- feature2_list[1:100]
  }

  if(length(feature2_list) == 0) {
    stop("No features found for the selected feature 2 type.")
  }

  # Define the worker function
  worker_function <- function(x) {
    results <- tryCatch({
      feature2_name <- feature2_list[x]

      # Get feature2 data using the same logic as feature1
      if (inherits(dromaset_object, "DromaSet")) {
        # Single DromaSet
        if (feature2_type %in% c("drug")) {
          feature2_data <- loadTreatmentResponseNormalized(dromaset_object,
                                               drugs = feature2_name,
                                               data_type = data_type,
                                               tumor_type = tumor_type,
                                               return_data = TRUE)

          if (is.matrix(feature2_data) && feature2_name %in% rownames(feature2_data)) {
            feature2_vector <- as.numeric(feature2_data[feature2_name, ])
            names(feature2_vector) <- colnames(feature2_data)
            selected_feas2 <- list()
            selected_feas2[[dromaset_object@name]] <- feature2_vector[!is.na(feature2_vector)]
          } else {
            return(NULL)
          }
        } else {
          # Molecular profile data
          feature2_data <- loadMolecularProfilesNormalized(dromaset_object,
                                               molecular_type = feature2_type,
                                               data_type = data_type,
                                               tumor_type = tumor_type,
                                               return_data = TRUE)

          if (is_continuous2) {
            # Continuous data
            if (is.matrix(feature2_data) && feature2_name %in% rownames(feature2_data)) {
              feature2_vector <- as.numeric(feature2_data[feature2_name, ])
              names(feature2_vector) <- colnames(feature2_data)
              selected_feas2 <- list()
              selected_feas2[[dromaset_object@name]] <- feature2_vector[!is.na(feature2_vector)]
            } else {
              return(NULL)
            }
          } else {
            # Discrete data
            if (is.data.frame(feature2_data)) {
              if ("cells" %in% colnames(feature2_data)) {
                sample_ids <- feature2_data$cells[feature2_data$genes == feature2_name]
              } else if ("samples" %in% colnames(feature2_data)) {
                sample_ids <- feature2_data$samples[feature2_data$genes == feature2_name]
              } else {
                sample_ids <- character(0)
              }
              selected_feas2 <- list()
              selected_feas2[[dromaset_object@name]] <- sample_ids
            } else {
              return(NULL)
            }
          }
        }
      } else {
        # MultiDromaSet
        if (feature2_type %in% c("drug")) {
          feature2_data <- loadMultiProjectTreatmentResponseNormalized(dromaset_object,
                                                            drugs = feature2_name,
                                                            overlap_only = overlap_only,
                                                            data_type = data_type,
                                                            tumor_type = tumor_type)

          selected_feas2 <- lapply(feature2_data, function(drug_matrix) {
            if (is.matrix(drug_matrix) && feature2_name %in% rownames(drug_matrix)) {
              drug_vector <- as.numeric(drug_matrix[feature2_name, ])
              names(drug_vector) <- colnames(drug_matrix)
              return(drug_vector[!is.na(drug_vector)])
            }
            return(NULL)
          })
        } else {
          # Molecular profile data
          feature2_data <- loadMultiProjectMolecularProfilesNormalized(dromaset_object,
                                                            molecular_type = feature2_type,
                                                            data_type = data_type,
                                                            tumor_type = tumor_type)

          if (is_continuous2) {
            # Continuous data
            selected_feas2 <- lapply(feature2_data, function(omics_matrix) {
              if (is.matrix(omics_matrix) && feature2_name %in% rownames(omics_matrix)) {
                omics_vector <- as.numeric(omics_matrix[feature2_name, ])
                names(omics_vector) <- colnames(omics_matrix)
                return(omics_vector[!is.na(omics_vector)])
              }
              return(NULL)
            })
          } else {
            # Discrete data
            selected_feas2 <- lapply(feature2_data, function(omics_df) {
              if (is.data.frame(omics_df)) {
                if ("cells" %in% colnames(omics_df)) {
                  sample_ids <- omics_df$cells[omics_df$genes == feature2_name]
                } else if ("samples" %in% colnames(omics_df)) {
                  sample_ids <- omics_df$samples[omics_df$genes == feature2_name]
                } else {
                  sample_ids <- character(0)
                }
                return(sample_ids)
              }
              return(NULL)
            })
          }
        }

        # Remove NULL entries
        selected_feas2 <- selected_feas2[!sapply(selected_feas2, is.null)]
      }

      if (is.null(selected_feas2) || length(selected_feas2) == 0) return(NULL)

      # Filter selected_feas2 to ensure each dataset has at least 3 samples
      selected_feas2 <- lapply(selected_feas2, function(dataset) {
        # Remove NA values
        dataset <- na.omit(dataset)
        # Check if the dataset has at least 3 samples after NA removal
        if (length(dataset) < 3) {
          return(NULL)
        } else {
          return(dataset)
        }
      })

      # Remove NULL entries
      selected_feas2 <- selected_feas2[!sapply(selected_feas2, is.null)]

      # Skip if no sufficient data remains after filtering
      if(length(selected_feas2) == 0) return(NULL)

      # do statistics test based on four circumstances
      # con vs con ----
      if (is_continuous1 && is_continuous2) {
        selected_pair <- pairContinuousFeatures(selected_feas1, selected_feas2)
        cal_meta_re <- metaCalcConCon(selected_pair)
        # dis vs con ----
      } else if ((is_continuous1 && !is_continuous2) || (!is_continuous1 && is_continuous2)) {
        if (is_continuous1 && !is_continuous2){
          selected_pair <- pairDiscreteFeatures(selected_feas2, selected_feas1)
        } else {
          selected_pair <- pairDiscreteFeatures(selected_feas1, selected_feas2)
        }
        cal_meta_re <- metaCalcConDis(selected_pair)
        # dis vs dis ----
      } else {
        # For discrete vs discrete, we need sample metadata
        # This is a limitation - we'll skip this for now or implement a workaround
        return(NULL)
      }

      if(is.null(cal_meta_re)) return(NULL)
      results <- data.frame(
        p_value = cal_meta_re[["pval.random"]],
        effect_size = cal_meta_re[["TE.random"]]
      #   N = length(cal_meta_re[["studlab"]])
      )
    }, error = function(e) {
      # Log error but continue processing
      message(sprintf("Error processing feature %d (%s): %s", x, feature2_list[x], e$message))
      NULL
    })

    # Update progress if callback provided
    if(!is.null(progress_callback)) {
      progress_callback(x, length(feature2_list),
                        difftime(Sys.time(), start_time, units = "secs"))
    }

    return(results)
  }
  message("Please be patient, it may take long time to run.")
  # Use parallel processing if cores > 1
  if (cores > 1) {
    # Initialize snowfall
    sfInit(parallel = TRUE, cpus = cores)

    # Export required data and functions
    sfExport("dromaset_object", "selected_feas1", "feature2_list",
             "is_continuous1", "is_continuous2",
             "feature1_type", "feature2_type", "data_type", "tumor_type", "overlap_only",
             "start_time")

    # Export functions
    # sfExport("loadTreatmentResponseNormalized", "loadMolecularProfilesNormalized",
    #          "loadMultiProjectTreatmentResponseNormalized", "loadMultiProjectMolecularProfilesNormalized",
    #          "pairContinuousFeatures", "pairDiscreteFeatures",
    #          "metaCalcConCon", "metaCalcConDis")

    # Load required packages on worker nodes
    sfLibrary(meta)
    sfLibrary(metafor)
    sfLibrary(effsize)
    sfLibrary(DROMA.Set)
    sfLibrary(Droma.R)
    # Run parallel computation
    cal_re_list <- sfLapply(1:length(feature2_list), worker_function)

    # Clean up snowfall
    sfStop()
  } else {
    # Run sequential computation
    cal_re_list <- lapply(1:length(feature2_list), worker_function)
  }

  # Process results
  valid_results <- !sapply(cal_re_list, is.null)
  fea_names <- feature2_list[valid_results]
  cal_re_list <- cal_re_list[valid_results]

  if (length(cal_re_list) == 0) {
    stop("No valid results found for the selected features. Please try others.")
  }

  cal_re_df <- do.call(rbind, cal_re_list)
  cal_re_df$name <- fea_names

  # Log completion
  total_time <- difftime(Sys.time(), start_time, units = "secs")
  message(sprintf("Analysis completed in %s", formatTime(as.numeric(total_time))))
  message(sprintf("Found %d significant associations out of %d features.",
                  sum(cal_re_df$p_value < 0.05), nrow(cal_re_df)))

  return(cal_re_df)
}




================================================
FILE: R/FuncDataLoaders.R
================================================
# Data Loading Functions with Z-score Normalization ----

#' Load molecular profiles with optional z-score normalization
#'
#' @description Wrapper function for loadMolecularProfiles that applies z-score normalization by default
#' @param dromaset_object A DromaSet object
#' @param molecular_type Type of molecular data to load (e.g., "mRNA", "cnv", "meth", "proteinrppa", "proteinms")
#' @param features Optional vector of specific features to load. If NULL, loads all features
#' @param data_type Filter by data type ("all", "CellLine", "PDO", "PDC", "PDX")
#' @param tumor_type Filter by tumor type ("all" or specific tumor types)
#' @param zscore Logical, whether to apply z-score normalization (default: TRUE)
#' @param return_data Logical, whether to return the data directly (default: TRUE)
#' @return Matrix or data frame with molecular profile data, optionally z-score normalized
#' @export
#' @examples
#' \dontrun{
#' # Load mRNA data with z-score normalization (default)
#' gCSI <- createDromaSetFromDatabase("gCSI", "path/to/droma.sqlite")
#' mrna_data <- loadMolecularProfilesNormalized(gCSI, "mRNA", features = "ABCB1")
#'
#' # Load without z-score normalization
#' mrna_raw <- loadMolecularProfilesNormalized(gCSI, "mRNA", features = "ABCB1", zscore = FALSE)
#'
#' # Load all mRNA features with normalization
#' all_mrna <- loadMolecularProfilesNormalized(gCSI, "mRNA")
#' }
loadMolecularProfilesNormalized <- function(dromaset_object,
                                          molecular_type,
                                          features = NULL,
                                          data_type = "all",
                                          tumor_type = "all",
                                          zscore = TRUE,
                                          return_data = TRUE) {

  # Validate input object
  if (!inherits(dromaset_object, "DromaSet")) {
    stop("Input must be a DromaSet object from DROMA.Set package")
  }

  # Load molecular profiles using DROMA.Set function
  molecular_data <- loadMolecularProfiles(
    dromaset_object,
    molecular_type = molecular_type,
    features = features,
    data_type = data_type,
    tumor_type = tumor_type,
    return_data = return_data
  )

  # Apply z-score normalization if requested and data is continuous
  if (zscore && !is.null(molecular_data)) {
    # Check if data is continuous (matrix format) and suitable for normalization
    continuous_types <- c("mRNA", "cnv", "meth", "proteinrppa", "proteinms")

    if (molecular_type %in% continuous_types && is.matrix(molecular_data)) {
      # Apply z-score normalization
      molecular_data <- zscoreNormalize(molecular_data)

      # Add attribute to indicate normalization was applied
      attr(molecular_data, "zscore_normalized") <- TRUE
    } else if (zscore && !molecular_type %in% continuous_types) {
      warning(paste("Z-score normalization not applicable for molecular type:", molecular_type))
    }
  }

  return(molecular_data)
}

#' Load treatment response data with optional z-score normalization
#'
#' @description Wrapper function for loadTreatmentResponse that applies z-score normalization by default
#' @param dromaset_object A DromaSet object
#' @param drugs Optional vector of specific drugs to load. If NULL, loads all drugs
#' @param data_type Filter by data type ("all", "CellLine", "PDO", "PDC", "PDX")
#' @param tumor_type Filter by tumor type ("all" or specific tumor types)
#' @param zscore Logical, whether to apply z-score normalization (default: TRUE)
#' @param return_data Logical, whether to return the data directly (default: TRUE)
#' @return Matrix with treatment response data, optionally z-score normalized
#' @export
#' @examples
#' \dontrun{
#' # Load drug data with z-score normalization (default)
#' gCSI <- createDromaSetFromDatabase("gCSI", "path/to/droma.sqlite")
#' drug_data <- loadTreatmentResponseNormalized(gCSI, drugs = "Paclitaxel")
#'
#' # Load without z-score normalization
#' drug_raw <- loadTreatmentResponseNormalized(gCSI, drugs = "Paclitaxel", zscore = FALSE)
#'
#' # Load all drug data with normalization
#' all_drugs <- loadTreatmentResponseNormalized(gCSI)
#' }
loadTreatmentResponseNormalized <- function(dromaset_object,
                                          drugs = NULL,
                                          data_type = "all",
                                          tumor_type = "all",
                                          zscore = TRUE,
                                          return_data = TRUE) {

  # Validate input object
  if (!inherits(dromaset_object, "DromaSet")) {
    stop("Input must be a DromaSet object from DROMA.Set package")
  }

  # Load treatment response using DROMA.Set function
  treatment_data <- loadTreatmentResponse(
    dromaset_object,
    drugs = drugs,
    data_type = data_type,
    tumor_type = tumor_type,
    return_data = return_data
  )

  # Apply z-score normalization if requested
  if (zscore && !is.null(treatment_data) && is.matrix(treatment_data)) {
    # Apply z-score normalization
    treatment_data <- zscoreNormalize(treatment_data)

    # Add attribute to indicate normalization was applied
    attr(treatment_data, "zscore_normalized") <- TRUE
  }

  return(treatment_data)
}

#' Load multi-project molecular profiles with optional z-score normalization
#'
#' @description Wrapper function for loadMultiProjectMolecularProfiles that applies z-score normalization by default
#' @param multidromaset_object A MultiDromaSet object
#' @param molecular_type Type of molecular data to load (e.g., "mRNA", "cnv", "meth", "proteinrppa", "proteinms")
#' @param features Optional vector of specific features to load. If NULL, loads all features
#' @param overlap_only Logical, whether to use only overlapping samples (default: FALSE)
#' @param data_type Filter by data type ("all", "CellLine", "PDO", "PDC", "PDX")
#' @param tumor_type Filter by tumor type ("all" or specific tumor types)
#' @param zscore Logical, whether to apply z-score normalization (default: TRUE)
#' @return List of matrices/data frames with molecular profile data from each project, optionally z-score normalized
#' @export
#' @examples
#' \dontrun{
#' # Load mRNA data across projects with z-score normalization (default)
#' multi_set <- createMultiDromaSetFromDatabase(c("gCSI", "CCLE"), "path/to/droma.sqlite")
#' mrna_data <- loadMultiProjectMolecularProfilesNormalized(multi_set, "mRNA", features = "ABCB1")
#'
#' # Load without z-score normalization
#' mrna_raw <- loadMultiProjectMolecularProfilesNormalized(multi_set, "mRNA",
#'                                                         features = "ABCB1", zscore = FALSE)
#' }
loadMultiProjectMolecularProfilesNormalized <- function(multidromaset_object,
                                                      molecular_type,
                                                      features = NULL,
                                                      overlap_only = FALSE,
                                                      data_type = "all",
                                                      tumor_type = "all",
                                                      zscore = TRUE) {

  # Validate input object
  if (!inherits(multidromaset_object, "MultiDromaSet")) {
    stop("Input must be a MultiDromaSet object from DROMA.Set package")
  }

  # Load molecular profiles using DROMA.Set function
  molecular_data_list <- loadMultiProjectMolecularProfiles(
    multidromaset_object,
    molecular_type = molecular_type,
    features = features,
    overlap_only = overlap_only,
    data_type = data_type,
    tumor_type = tumor_type
  )

  # Apply z-score normalization if requested and data is continuous
  if (zscore && !is.null(molecular_data_list)) {
    # Check if data is continuous (matrix format) and suitable for normalization
    continuous_types <- c("mRNA", "cnv", "meth", "proteinrppa", "proteinms")

    if (molecular_type %in% continuous_types) {
      # Apply z-score normalization to each project's data
      molecular_data_list <- lapply(molecular_data_list, function(project_data) {
        if (is.matrix(project_data)) {
          normalized_data <- zscoreNormalize(project_data)
          # Add attribute to indicate normalization was applied
          attr(normalized_data, "zscore_normalized") <- TRUE
          return(normalized_data)
        } else {
          return(project_data)
        }
      })
    } else if (zscore && !molecular_type %in% continuous_types) {
      warning(paste("Z-score normalization not applicable for molecular type:", molecular_type))
    }
  }

  return(molecular_data_list)
}

#' Load multi-project treatment response data with optional z-score normalization
#'
#' @description Wrapper function for loadMultiProjectTreatmentResponse that applies z-score normalization by default
#' @param multidromaset_object A MultiDromaSet object
#' @param drugs Optional vector of specific drugs to load. If NULL, loads all drugs
#' @param overlap_only Logical, whether to use only overlapping samples (default: FALSE)
#' @param data_type Filter by data type ("all", "CellLine", "PDO", "PDC", "PDX")
#' @param tumor_type Filter by tumor type ("all" or specific tumor types)
#' @param zscore Logical, whether to apply z-score normalization (default: TRUE)
#' @return List of matrices with treatment response data from each project, optionally z-score normalized
#' @export
#' @examples
#' \dontrun{
#' # Load drug data across projects with z-score normalization (default)
#' multi_set <- createMultiDromaSetFromDatabase(c("gCSI", "CCLE"), "path/to/droma.sqlite")
#' drug_data <- loadMultiProjectTreatmentResponseNormalized(multi_set, drugs = "Paclitaxel")
#'
#' # Load without z-score normalization
#' drug_raw <- loadMultiProjectTreatmentResponseNormalized(multi_set, drugs = "Paclitaxel",
#'                                                        zscore = FALSE)
#' }
loadMultiProjectTreatmentResponseNormalized <- function(multidromaset_object,
                                                      drugs = NULL,
                                                      overlap_only = FALSE,
                                                      data_type = "all",
                                                      tumor_type = "all",
                                                      zscore = TRUE) {

  # Validate input object
  if (!inherits(multidromaset_object, "MultiDromaSet")) {
    stop("Input must be a MultiDromaSet object from DROMA.Set package")
  }

  # Load treatment response using DROMA.Set function
  treatment_data_list <- loadMultiProjectTreatmentResponse(
    multidromaset_object,
    drugs = drugs,
    overlap_only = overlap_only,
    data_type = data_type,
    tumor_type = tumor_type
  )

  # Apply z-score normalization if requested
  if (zscore && !is.null(treatment_data_list)) {
    # Apply z-score normalization to each project's data
    treatment_data_list <- lapply(treatment_data_list, function(project_data) {
      if (is.matrix(project_data)) {
        normalized_data <- zscoreNormalize(project_data)
        # Add attribute to indicate normalization was applied
        attr(normalized_data, "zscore_normalized") <- TRUE
        return(normalized_data)
      } else {
        return(project_data)
      }
    })
  }

  return(treatment_data_list)
}

#' Apply z-score normalization to existing data
#'
#' @description Convenience function to apply z-score normalization to already loaded data
#' @param data Matrix or data frame with features in rows and samples in columns
#' @param check_type Logical, whether to check if data appears to be continuous (default: TRUE)
#' @return Z-score normalized matrix
#' @export
#' @examples
#' \dontrun{
#' # Apply normalization to existing data
#' normalized_data <- applyZscoreNormalization(raw_data)
#'
#' # Skip type checking
#' normalized_data <- applyZscoreNormalization(raw_data, check_type = FALSE)
#' }
applyZscoreNormalization <- function(data, check_type = TRUE) {

  if (!is.matrix(data) && !is.data.frame(data)) {
    stop("Input data must be a matrix or data frame")
  }

  # Convert to matrix if data frame
  if (is.data.frame(data)) {
    data <- as.matrix(data)
  }

  # Check if data appears to be continuous
  if (check_type) {
    # Simple heuristic: if more than 50% of values are unique, assume continuous
    unique_ratio <- length(unique(as.vector(data))) / length(as.vector(data))
    if (unique_ratio < 0.1) {
      warning("Data appears to be discrete. Z-score normalization may not be appropriate.")
    }
  }

  # Apply z-score normalization
  normalized_data <- zscoreNormalize(data)

  # Add attribute to indicate normalization was applied
  attr(normalized_data, "zscore_normalized") <- TRUE

  return(normalized_data)
}

#' Check if data has been z-score normalized
#'
#' @description Utility function to check if data has the z-score normalization attribute
#' @param data Matrix or data frame to check
#' @return Logical indicating whether data has been z-score normalized
#' @export
#' @examples
#' \dontrun{
#' # Check if data is normalized
#' is_normalized <- isZscoreNormalized(my_data)
#' }
isZscoreNormalized <- function(data) {
  return(!is.null(attr(data, "zscore_normalized")) && attr(data, "zscore_normalized"))
}



================================================
FILE: R/FuncDrugFeature.R
================================================
# Data Processing Functions ----

#' Process Drug Sensitivity Data using DromaSet objects
#'
#' @description Creates a combined dataframe with raw and normalized drug sensitivity values from DromaSet or MultiDromaSet objects
#' @param dromaset_object Either a DromaSet or MultiDromaSet object
#' @param drug_name Character string specifying the drug name
#' @param data_type Filter by data type ("all", "CellLine", "PDC", "PDO", "PDX")
#' @param tumor_type Filter by tumor type (use "all" for all tumor types)
#' @param overlap_only For MultiDromaSet, whether to use only overlapping samples (default: FALSE).
#'   TRUE: Use only sample types present in all projects (recommended for meta-analysis)
#'   FALSE: Use all available samples from each project (may increase power but introduce bias)
#' @return A dataframe with combined raw and normalized drug sensitivity values
#' @export
#' @examples
#' \dontrun{
#' # Using DromaSet
#' gCSI <- createDromaSetFromDatabase("gCSI", "path/to/droma.sqlite")
#' drug_data <- processDrugData(gCSI, "Paclitaxel")
#'
#' # Using MultiDromaSet with overlapping samples (recommended for meta-analysis)
#' multi_set <- createMultiDromaSetFromDatabase(c("gCSI", "CCLE"))
#' drug_data <- processDrugData(multi_set, "Paclitaxel", overlap_only = FALSE)
#'
#' # Using MultiDromaSet with all samples (maximum sample size)
#' drug_data_all <- processDrugData(multi_set, "Paclitaxel", overlap_only = FALSE)
#' }
processDrugData <- function(dromaset_object, drug_name, data_type = "all", tumor_type = "all", overlap_only = FALSE) {
  if (drug_name == "") {
    stop("Please select a drug.")
  }

  # Validate input object
  if (!inherits(dromaset_object, c("DromaSet", "MultiDromaSet"))) {
    stop("Input must be a DromaSet or MultiDromaSet object from DROMA.Set package")
  }

  # Load drug data
  if (inherits(dromaset_object, "DromaSet")) {
    # Single DromaSet - Load normalized data
    drug_data <- loadTreatmentResponseNormalized(dromaset_object,
                                      drugs = drug_name,
                                      data_type = data_type,
                                      tumor_type = tumor_type,
                                      return_data = TRUE)

    # Convert matrix to list format for compatibility
    if (is.matrix(drug_data) && drug_name %in% rownames(drug_data)) {
      drug_vector <- as.numeric(drug_data[drug_name, ])
      names(drug_vector) <- colnames(drug_data)
      drug_data_list <- list()
      drug_data_list[[dromaset_object@name]] <- drug_vector[!is.na(drug_vector)]
    } else {
      stop("Drug not found in treatment response data")
    }

    # Load raw data (non-normalized)
    raw_drug_data <- loadTreatmentResponseNormalized(dromaset_object,
                                          drugs = drug_name,
                                          data_type = data_type,
                                          tumor_type = tumor_type,
                                          zscore = FALSE,
                                          return_data = TRUE)

    # Convert raw matrix to list format for compatibility
    if (is.matrix(raw_drug_data) && drug_name %in% rownames(raw_drug_data)) {
      raw_drug_vector <- as.numeric(raw_drug_data[drug_name, ])
      names(raw_drug_vector) <- colnames(raw_drug_data)
      raw_data_list <- list()
      raw_data_list[[dromaset_object@name]] <- raw_drug_vector[!is.na(raw_drug_vector)]
    } else {
      stop("Drug not found in raw treatment response data")
    }

  } else {
    # MultiDromaSet - Load normalized data
    drug_data <- loadMultiProjectTreatmentResponseNormalized(dromaset_object,
                                                  drugs = drug_name,
                                                  overlap_only = overlap_only,
                                                  data_type = data_type,
                                                  tumor_type = tumor_type)

    # Extract specific drug from each project
    drug_data_list <- lapply(drug_data, function(drug_matrix) {
      if (is.matrix(drug_matrix) && drug_name %in% rownames(drug_matrix)) {
        drug_vector <- as.numeric(drug_matrix[drug_name, ])
        names(drug_vector) <- colnames(drug_matrix)
        return(drug_vector[!is.na(drug_vector)])
      }
      return(NULL)
    })

    # Remove NULL entries
    drug_data_list <- drug_data_list[!sapply(drug_data_list, is.null)]

    # Load raw data (non-normalized)
    raw_drug_data <- loadMultiProjectTreatmentResponseNormalized(dromaset_object,
                                                      drugs = drug_name,
                                                      overlap_only = overlap_only,
                                                      data_type = data_type,
                                                      tumor_type = tumor_type,
                                                      zscore = FALSE)

    # Extract specific drug from each project for raw data
    raw_data_list <- lapply(raw_drug_data, function(drug_matrix) {
      if (is.matrix(drug_matrix) && drug_name %in% rownames(drug_matrix)) {
        drug_vector <- as.numeric(drug_matrix[drug_name, ])
        names(drug_vector) <- colnames(drug_matrix)
        return(drug_vector[!is.na(drug_vector)])
      }
      return(NULL)
    })

    # Remove NULL entries
    raw_data_list <- raw_data_list[!sapply(raw_data_list, is.null)]
  }

  # Get all study names (using union of keys from both lists)
  all_studies <- union(names(drug_data_list), names(raw_data_list))

  # Create an empty list to hold combined data for each study
  combined_data <- list()

  # For each study, process and combine the data
  for (study in all_studies) {
    if (study %in% names(drug_data_list) && study %in% names(raw_data_list)) {
      # Get values for this study
      drug_values <- drug_data_list[[study]]
      raw_values <- raw_data_list[[study]]

      # Get common sample IDs
      common_samples <- intersect(names(drug_values), names(raw_values))

      if (length(common_samples) > 0) {
        # Create dataframe with both values
        study_df <- data.frame(
          sampleid = common_samples,
          zscore_value = as.numeric(drug_values[common_samples]),
          raw_value = as.numeric(raw_values[common_samples]),
          study = study,
          stringsAsFactors = FALSE
        )

        combined_data[[study]] <- study_df
      }
    }
  }

  # Combine all studies into a single dataframe
  if (length(combined_data) > 0) {
    result_df <- bind_rows(combined_data)
    result_df <- na.omit(result_df)

    return(result_df)
  } else {
    return(NULL)
  }
}

#' Annotate Drug Sensitivity Data
#'
#' @description Adds sample annotations to drug sensitivity data
#' @details This function merges drug sensitivity data with sample annotations.
#'   It can obtain sample annotations from three sources, in order of preference:
#'   1. From the provided `sample_annotations` parameter
#'   2. From the global environment variable `sample_anno`
#'   3. From the SQLite database specified by `db_path`
#'
#' @param drug_data Dataframe containing drug sensitivity data from processDrugData
#' @param sample_annotations Dataframe containing sample annotations (default: uses global sample_anno)
#' @param db_path Optional path to SQLite database for loading sample annotations if not provided and not in global environment
#' @return A dataframe with drug sensitivity data and sample annotations
#' @export
#' @examples
#' \dontrun{
#' # Using existing sample_anno in global environment
#' drug_data <- processDrugData(gCSI, "Paclitaxel")
#' annotated_data <- annotateDrugData(drug_data)
#'
#' # Using provided sample annotations
#' my_annotations <- data.frame(SampleID = c("sample1", "sample2"),
#'                             TumorType = c("BRCA", "LUAD"))
#' annotated_data <- annotateDrugData(drug_data, sample_annotations = my_annotations)
#'
#' # Loading directly from database
#' annotated_data <- annotateDrugData(drug_data, db_path = "path/to/droma.sqlite")
#' }
annotateDrugData <- function(drug_data, sample_annotations = NULL, db_path = NULL) {
  if (is.null(drug_data)) {
    return(NULL)
  }

  # Use provided sample annotations or global sample_anno
  annotations <- sample_annotations
  if (is.null(annotations)) {
    if (!is.null(db_path) && file.exists(db_path)) {
      # Try to load sample annotations from the database
      tryCatch({
        # Load required package
        if (!requireNamespace("DBI", quietly = TRUE) || !requireNamespace("RSQLite", quietly = TRUE)) {
          warning("DBI and/or RSQLite packages not available. Cannot load sample annotations from database.")
          return(drug_data)
        }

        # Connect to database
        con <- DBI::dbConnect(RSQLite::SQLite(), db_path)
        on.exit(DBI::dbDisconnect(con), add = TRUE)

        # Query sample annotations
        annotations <- DBI::dbGetQuery(con, "SELECT * FROM sample_anno")
      }, error = function(e) {
        warning(paste("Failed to load sample annotations from database:", e$message,
                      "\nReturning non-annotated data."))
        return(drug_data)
      })
    } else {
      warning("sample_anno object not found and no valid db_path provided. Returning non-annotated data.")
      return(drug_data)
    }
  }

  # Merge drug data with annotations
  merged_df <- left_join(drug_data,
                         annotations %>% select(-ProjectID), # Remove ProjectID from the join
                         by = c("sampleid" = "SampleID"))

  # Clean up
  if ("ProjectRawName" %in% colnames(merged_df)) {
    merged_df$ProjectRawName <- NULL
  }

  merged_df <- unique(merged_df)
  return(merged_df)
}

#' Format Drug Data Table
#'
#' @description Creates a formatted datatable for drug sensitivity data
#' @param drug_data Dataframe containing drug sensitivity data
#' @param caption Caption text for the table
#' @return A formatted DT::datatable object
#' @export
formatDrugTable <- function(drug_data, caption = "Drug sensitivity data - showing both raw and Z-score normalized values") {
  if (is.null(drug_data) || nrow(drug_data) == 0) {
    return(NULL)
  }

  DT::datatable(
    drug_data,
    caption = htmltools::tags$caption(
      style = 'caption-side: top; text-align: left; color: black; font-size: 14px;',
      htmltools::strong(caption)
    ),
    options = list(
      pageLength = 10,
      scrollX = TRUE,
      dom = 'Bfrtip',
      buttons = c('copy', 'csv')
    ),
    extensions = 'Buttons',
    rownames = FALSE,
    filter = 'top'
  ) %>%
  # Format numeric columns to 3 decimal places
  DT::formatRound(columns = c('zscore_value', 'raw_value'), digits = 3)
}

# Visualization Functions ----
#' Get Drug Sensitivity Data using DromaSet objects
#'
#' @description Wrapper function that processes and returns drug sensitivity data from DromaSet or MultiDromaSet objects
#' @details This function combines the functionality of `processDrugData()` and `annotateDrugData()`.
#'   When `include_annotations = TRUE`, it will add sample annotations to the drug data.
#'   Sample annotations can be provided directly via the `sample_annotations` parameter,
#'   or loaded from the global `sample_anno` variable, or retrieved from the SQLite
#'   database specified by `db_path`.
#' @param dromaset_object Either a DromaSet or MultiDromaSet object
#' @param drug_name Character string specifying the drug name
#' @param data_type Filter by data type ("all", "CellLine", "PDC", "PDO", "PDX")
#' @param tumor_type Filter by tumor type (use "all" for all tumor types)
#' @param overlap_only For MultiDromaSet, whether to use only overlapping samples (default: FALSE).
#'   TRUE: Use only sample types present in all projects (recommended for meta-analysis)
#'   FALSE: Use all available samples from each project (may increase power but introduce bias)
#' @param include_annotations Logical indicating whether to include sample annotations
#' @param sample_annotations Optional dataframe containing sample annotations
#' @param db_path Optional path to SQLite database for loading sample annotations if not provided and not in global environment
#' @return A dataframe with drug sensitivity data
#' @export
#' @examples
#' \dontrun{
#' # Using DromaSet
#' gCSI <- createDromaSetFromDatabase("gCSI", "path/to/droma.sqlite")
#' drug_data <- getDrugSensitivityData(gCSI, "Paclitaxel")
#'
#' # Using MultiDromaSet with overlapping samples (recommended)
#' multi_set <- createMultiDromaSetFromDatabase(c("gCSI", "CCLE"))
#' drug_data <- getDrugSensitivityData(multi_set, "Paclitaxel",
#'                                    include_annotations = TRUE)
#'
#' # Using MultiDromaSet with all available samples
#' drug_data_all <- getDrugSensitivityData(multi_set, "Paclitaxel",
#'                                        overlap_only = FALSE,
#'                                        include_annotations = TRUE)
#'
#' # Using database path to load sample annotations
#' drug_data <- getDrugSensitivityData(gCSI, "Paclitaxel",
#'                                    include_annotations = TRUE,
#'                                    db_path = "path/to/droma.sqlite")
#'
#' # Using custom sample annotations
#' my_annotations <- data.frame(SampleID = c("sample1", "sample2"),
#'                             TumorType = c("BRCA", "LUAD"))
#' drug_data <- getDrugSensitivityData(gCSI, "Paclitaxel",
#'                                    include_annotations = TRUE,
#'                                    sample_annotations = my_annotations)
#' }
getDrugSensitivityData <- function(dromaset_object,
                                   drug_name,
                                   data_type = "all",
                                   tumor_type = "all",
                                   overlap_only = FALSE,
                                   include_annotations = TRUE,
                                   sample_annotations = NULL,
                                   db_path = NULL) {
  # Process drug data
  drug_data <- processDrugData(dromaset_object, drug_name, data_type, tumor_type, overlap_only)

  # Add annotations if requested
  if (include_annotations) {
    drug_data <- annotateDrugData(drug_data, sample_annotations, db_path)
  }

  return(drug_data)
}

#' Plot continuous variable comparison
#'
#' @description Creates a scatter plot with correlation statistics for a continuous variable
#' @param data Data frame containing the variables to plot
#' @param cont_column Name of the continuous column to use for x-axis
#' @param value_column Name of the value column to use for y-axis (default: "value")
#' @param value_label Label for the value variable (default: "Drug Sensitivity")
#' @return A ggplot2 object with the comparison plot
#' @export
plotContinuousComparison <- function(data, cont_column, value_column = "value", value_label = "Drug Sensitivity") {
  # Create scatter plot with correlation information
  p <- ggscatter(data, x = cont_column, y = value_column, alpha = 0.2) +
    stat_cor(size = 6, method = "spearman") +
    stat_smooth(formula = y ~ x, method = "lm") +
    theme_bw() +
    theme(
      axis.title = element_blank(),
      title = element_text(size = 15, face = "bold"),
      axis.text = element_text(size = 12)
    ) +
    ggtitle(paste(value_label, "vs", cont_column))


  return(p)
}

#' Plot continuous variable as groups
#'
#' @description Creates boxplots for binned groups of a continuous variable
#' @param data Data frame containing the variables to plot
#' @param cont_column Name of the continuous column to bin into groups
#' @param value_column Name of the value column to use for y-axis (default: "value")
#' @param value_label Label for the value variable (default: "Drug Sensitivity")
#' @param num_bins Number of bins to create from the continuous variable (default: 4)
#' @return A ggplot2 object with the grouped boxplot
#' @export
plotContinuousGroups <- function(data, cont_column, value_column = "value", value_label = "Drug Sensitivity", num_bins = 4) {
  # Create bins for the continuous variable
  cont_values <- data[[cont_column]]

  # Create bins
  cont_bins <- cut(cont_values,
                   breaks = num_bins,
                   include.lowest = TRUE,
                   labels = FALSE)

  # Create labels for groups
  cont_range <- range(cont_values, na.rm = TRUE)
  bin_width <- diff(cont_range) / num_bins
  group_labels <- sapply(1:num_bins, function(i) {
    lower <- cont_range[1] + (i-1) * bin_width
    upper <- cont_range[1] + i * bin_width
    paste0(round(lower), "-", round(upper))
  })

  # Add group information to data
  group_column <- paste0(cont_column, "_group")
  label_column <- paste0(cont_column, "_group_label")

  data[[group_column]] <- cont_bins
  data[[label_column]] <- group_labels[data[[group_column]]]

  # Create boxplot with statistical test
  p <- ggboxplot(data, x = label_column, y = value_column,
                 fill = label_column, palette = "jco",
                 add = "jitter", add.params = list(alpha = 0.15)) +
    stat_compare_means(size = 6, label.x = 0.8,
                       label.y = (max(data[[value_column]]) - max(data[[value_column]])/8),
                       label = "p.format") +
    theme_bw() +
    theme(
      axis.title = element_blank(),
      title = element_text(size = 15, face = "bold"),
      axis.text = element_text(size = 12),
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "none"
    ) +
    ggtitle(paste(value_label, "by", cont_column, "Group"))


  return(p)
}

#' Plot category comparison
#'
#' @description Creates boxplots comparing values across categories
#' @param data Data frame containing the variables to plot
#' @param category_column Name of the categorical column to use for grouping
#' @param value_column Name of the value column to use for y-axis (default: "value")
#' @param value_label Label for the value variable (default: "Drug Sensitivity")
#' @return A ggplot2 object with the category comparison plot
#' @export
plotCategoryComparison <- function(data, category_column, value_column = "value", value_label = "Drug Sensitivity") {
  # Count observations per category and filter out categories with too few samples
  category_counts <- table(data[[category_column]])
  valid_categories <- names(category_counts)[category_counts >= 3]

  if (length(valid_categories) == 0) {
    return(ggplot() +
             annotate("text", x = 0.5, y = 0.5,
                      label = "Not enough samples per category for comparison") +
             theme_void())
  }

  data_filtered <- data[data[[category_column]] %in% valid_categories, ]

  # Create improved boxplot with consistent styling
  p <- ggboxplot(data_filtered, x = category_column, y = value_column,
                 fill = category_column,
                 palette = bright_palette_26,
                 add = "jitter",
                 add.params = list(alpha = 0.15)) +
    theme_bw() +
    theme(
      axis.title = element_blank(),
      title = element_text(size = 15, face = "bold"),
      axis.text = element_text(size = 12),
      axis.text.x = element_text(angle = 45, hjust = 1),
      legend.position = "none"
    ) +
    ggtitle(paste(value_label, "by", category_column))


  # Add statistical comparison with appropriate method
  if (length(valid_categories) >= 2) {
    max_y <- max(data_filtered[[value_column]], na.rm = TRUE)
    label_x_pos <- length(valid_categories) / 2.5
    if (length(valid_categories) == 2) {
      # For two groups, use wilcoxon with clear label positioning
      p <- p + stat_compare_means(size = 6,
                                  label.x = label_x_pos,
                                  label.y = (max_y - max_y/8),
                                  label = "p.format")
    } else {
      # For more than two groups, use Kruskal-Wallis
      # Add global p-value at top
      p <- p + stat_compare_means(method = "kruskal.test",
                                  size = 6,
                                  label.x = label_x_pos,
                                  label.y = max_y + (max_y * 0.15),
                                  label = "p.format")
    }
  }

  return(p)
}

#' Create drug comparison plot
#'
#' @description Creates appropriate comparison plots based on variable type
#' @param data Data frame containing the variables to plot
#' @param comparison_var Name of the variable to compare against drug sensitivity
#' @param value_column Name of the value column to use for y-axis (default: "value")
#' @param value_label Label for the value variable (default: "Drug Sensitivity")
#' @param num_bins Number of bins to create from continuous variables (default: 4)
#' @param show_groups_boxplot Logical, whether to show grouped boxplot for continuous variables
#' @return A ggplot2 object or grid with comparison plots
#' @export
createDrugComparisonPlot <- function(data, comparison_var, value_column = "value", value_label = "Drug Sensitivity",
                                     num_bins = 4, show_groups_boxplot = TRUE) {
  # Handle missing values in the comparison variable
  data <- data[!is.na(data[[comparison_var]]), ]

  if (nrow(data) == 0) {
    return(ggplot() +
             annotate("text", x = 0.5, y = 0.5, label = "No data available for this comparison") +
             theme_void())
  }

  # Check if the comparison variable is numeric/continuous
  if (is.numeric(data[[comparison_var]])) {
    # For continuous variables
    p1 <- plotContinuousComparison(data, cont_column = comparison_var,
                                   value_column = value_column, value_label = value_label)

    # Also create a boxplot with bins if requested
    if (show_groups_boxplot) {
      # Create grouped boxplot
      p2 <- plotContinuousGroups(data, cont_column = comparison_var,
                                 value_column = value_column, value_label = value_label,
                                 num_bins = num_bins)

      # Return grid of both plots
      return(patchwork::wrap_plots(p1,p2, ncol = 2))
    }

    return(p1)
  } else {
    # For categorical variables
    return(plotCategoryComparison(data, category_column = comparison_var,
                                  value_column = value_column, value_label = value_label))
  }
}



================================================
FILE: R/FuncDrugOmicPair.R
================================================
# Continuous Data Functions ----

#' Pair continuous omics and drug data
#'
#' @description Creates paired datasets of omics and drug response data from multiple sources
#' @param myOmics List of omics data vectors
#' @param myDrugs List of drug response data vectors
#' @param merged Logical, if TRUE, creates an additional merged dataset combining all pairs
#' @return A list of paired omics-drug datasets
#' @export
pairDrugOmic <- function(myOmics, myDrugs, merged = FALSE){
  pair_list2 <- lapply(1:length(myOmics), function(x){
    omic_sel <- myOmics[[x]]
    pair_list <- lapply(1:length(myDrugs), function(y){
      drug_sel <- myDrugs[[y]]
      omic_sel <- na.omit(omic_sel); drug_sel <- na.omit(drug_sel)
      if(length(na.omit(omic_sel)) == 0 | length(na.omit(drug_sel)) == 0){ return(NULL) }
      intersected_cells <- intersect(names(omic_sel), names(drug_sel))
      omic_sel <- omic_sel[match(intersected_cells, names(omic_sel))]
      drug_sel <- drug_sel[match(intersected_cells, names(drug_sel))]
      if(length(na.omit(omic_sel)) < 3 | length(na.omit(drug_sel)) < 3){ return(NULL) }
      list("omic" = omic_sel,
           "drug" = drug_sel)
    })
    names(pair_list) <- paste0(names(myOmics)[x], "_",
                               names(myDrugs))
    pair_list
  })
  pair_list2 <- unlist(pair_list2, recursive = F)
  pair_list2 <- pair_list2[!sapply(pair_list2, is.null)]
  if(length(pair_list2) < 1) {stop("Please try another drug-omic pair. This pair does not have result.")}
  # If merged is TRUE and z-score normalization is enabled, create a merged dataset
  if(merged & length(pair_list2) > 1) {
    # Create a merged dataset by combining all pairs using the more efficient approach
    combined_list <- list(
      # Combine all omic vectors
      unlist(lapply(pair_list2, function(x) x$omic)),

      # Combine all drug vectors
      unlist(lapply(pair_list2, function(x) x$drug))
    )
    pair_list2[["merged_dataset"]] <- list(
      "omic" = combined_list[[1]],
      "drug" = combined_list[[2]]
    )
  }
  pair_list2
}

#' Analyze continuous drug-omics pairs
#'
#' @description Performs meta-analysis on continuous drug-omic pairs using Spearman correlation
#' @param myPairs List of paired omics-drug datasets from pairDrugOmic
#' @return Meta-analysis results object or NULL if analysis couldn't be performed
#' @export
analyzeContinuousDrugOmic <- function(myPairs) {
  options(warn = -1)
  # Initialize list to store correlation results
  test_list <- list()
  valid_indices <- c()

  # Analyze each pair
  for (x in seq_along(myPairs)) {
    # Skip merged dataset for meta-analysis
    if (names(myPairs)[x] == "merged_dataset") next

    # Try to perform correlation test
    tryCatch({
      omic_sel <- myPairs[[x]]$omic
      drug_sel <- myPairs[[x]]$drug

      # Check for valid data
      if (length(omic_sel) < 3 || length(drug_sel) < 3) next

      # Perform correlation test

      cor_re <- cor.test(omic_sel, drug_sel, method = "spearman")
      test_list[[x]] <- data.frame(
        p = cor_re$p.value,
        effect = cor_re$estimate,
        N = length(omic_sel)
      )
      # Track valid indices for proper study name mapping
      valid_indices <- c(valid_indices, x)
    }, error = function(e) {
      # Continue to next pair on error
    })
  }

  # Return NULL if no correlations could be calculated
  if (length(test_list) < 1) return(NULL)

  # Prepare data for meta-analysis
  meta_df <- do.call(rbind, test_list)
  # Use valid_indices to correctly map study names
  meta_df$study <- names(myPairs)[valid_indices]
  meta_df$se <- sqrt((1 - meta_df$effect^2) / (meta_df$N - 2))
  meta_df$z <- 0.5 * log((1 + meta_df$effect) / (1 - meta_df$effect))  # Fisher's z
  meta_df$se_z <- 1 / sqrt(meta_df$N - 3)

  # Perform meta-analysis
  tryCatch({
    # Only perform meta-analysis if we have at least 2 studies
    if (nrow(meta_df) >= 2) {
      cal_meta_re <- metagen(TE = z,
                             seTE = se_z,
                             data = meta_df,
                             sm = "Z",
                             studlab = study)
      return(cal_meta_re)
    } else {
      return(NULL)
    }
  }, error = function(e) {
    return(NULL)
  })
}

# Discrete Data Functions ----

#' Pair discrete omics and drug data
#'
#' @description Creates paired datasets of discrete omics and drug response data
#' @param myOmics List of discrete omics data (samples with feature present)
#' @param myDrugs List of drug response data vectors
#' @param merged Logical, if TRUE, creates an additional merged dataset combining all pairs
#' @return A list of paired drug-omics datasets with yes/no groups
#' @export
pairDiscreteDrugOmic <- function(myOmics, myDrugs, merged = FALSE){
  pair_list2 <- lapply(1:length(myOmics), function(x){
    omic_sel <- myOmics[[x]]
    pair_list <- lapply(1:length(myDrugs), function(y){
      drug_sel <- myDrugs[[y]]
      yes_drugs <- na.omit(drug_sel[names(drug_sel) %in% omic_sel])
      no_drugs <- na.omit(drug_sel[!names(drug_sel) %in% omic_sel])
      if(length(yes_drugs) < 3 | length(no_drugs) < 3){
        return(NULL)
      }
      list(yes = yes_drugs,
           no = no_drugs)
    })
    names(pair_list) <- paste0(names(myOmics)[x], "_",
                               names(myDrugs))
    pair_list
  })
  pair_list2 <- unlist(pair_list2, recursive = F)
  pair_list2 <- pair_list2[!sapply(pair_list2, is.null)]
  if(length(pair_list2) < 1){stop("Please try another drug-omic pair. This pair does not have result.")}
  # If merged is TRUE and z-score normalization is enabled, create a merged dataset
  if(merged & length(pair_list2) > 1) {
    # Create a merged dataset by combining all pairs using the more efficient approach
    combined_list <- list(
      # Combine all yes vectors
      unlist(lapply(pair_list2, function(x) x$yes)),

      # Combine all no vectors
      unlist(lapply(pair_list2, function(x) x$no))
    )

    # Only add merged dataset if we have enough data points
    pair_list2[["merged_dataset"]] <- list(
      "yes" = combined_list[[1]],
      "no" = combined_list[[2]]
    )
  }
  pair_list2
}

#' Analyze discrete drug-omics pairs
#'
#' @description Performs meta-analysis on discrete drug-omic pairs using Wilcoxon test and Cliff's Delta
#' @param myPairs List of paired drug-omics datasets from pairDiscreteDrugOmic
#' @return Meta-analysis results object or NULL if analysis couldn't be performed
#' @export
analyzeDiscreteDrugOmic <- function(myPairs) {
  options(warn = -1)
  # Initialize list to store test results
  test_list <- list()
  valid_indices <- c()

  # Analyze each pair
  for (x in seq_along(myPairs)) {
    # Skip merged dataset for meta-analysis
    if (names(myPairs)[x] == "merged_dataset") next

    # Try to perform Wilcoxon test and effect size calculation
    tryCatch({
      yes_drugs <- myPairs[[x]]$yes
      no_drugs <- myPairs[[x]]$no

      # Check for valid data
      if (length(yes_drugs) < 3 || length(no_drugs) < 3) next

      # Perform statistical test
      wilcox_test <- wilcox.test(no_drugs, yes_drugs)
      cliff_delta <- cliff.delta(no_drugs, yes_drugs)

      # Store results
      test_list[[x]] <- data.frame(
        p = wilcox_test$p.value,
        effect = cliff_delta$estimate,
        N = length(yes_drugs) + length(no_drugs),
        n1 = length(yes_drugs),
        n2 = length(no_drugs)
      )
      valid_indices <- c(valid_indices, x)
    }, error = function(e) {
      # Continue to next pair on error
    })
  }

  # Return NULL if no tests could be performed
  if (length(test_list) < 1) return(NULL)

  # Prepare data for meta-analysis
  meta_df <- do.call(rbind, test_list)
  meta_df$study <- names(myPairs)[valid_indices]

  # Calculate standard error for Cliff's Delta
  meta_df$se <- sqrt((1 - meta_df$effect^2) * (meta_df$n1 + meta_df$n2 + 1) /
                       (12 * meta_df$n1 * meta_df$n2))

  # Perform meta-analysis
  tryCatch({
    # Only perform meta-analysis if we have at least 2 studies
    if (nrow(meta_df) >= 2) {
      meta_result <- metagen(TE = effect,
                             seTE = se,
                             data = meta_df,
                             sm = "CMD",  # Custom Mean Difference (using Cliff's Delta)
                             studlab = study)
      return(meta_result)
    } else {
      return(NULL)
    }
  }, error = function(e) {
    return(NULL)
  })
}

# Plot Functions ----

#' Create a forest plot for meta-analysis results
#'
#' @description Creates a standardized forest plot for visualizing meta-analysis results
#' @param meta_obj Meta-analysis object from metagen() function
#' @param xlab Label for x-axis
#' @param show_common Logical, whether to show common effect model
#' @return A forest plot visualization
#' @export
createForestPlot <- function(meta_obj,
                             xlab = "Effect Size (95% CI)",
                             show_common = FALSE) {
  # Validate input
  if (!inherits(meta_obj, "meta") && !inherits(meta_obj, "metagen")) {
    stop("Input must be a meta-analysis object from the 'meta' package")
  }

  # Format p-value text for random effects model
  p_val <- meta_obj$pval.random
  p_text <- if(p_val < 0.001) {
    paste("Random-Effects Model (p =", format(p_val, scientific = TRUE, digits = 3), ")")
  } else {
    paste("Random-Effects Model (p =", round(p_val, 3), ")")
  }

  # Create forest plot
  meta::forest(meta_obj,
               xlab = xlab,
               slab = "study",
               print.pval.common = show_common,
               boxsize = 0.2,
               lineheight = "auto",
               print.pval.Q = FALSE,
               print.I2 = FALSE,
               print.tau2 = FALSE,
               common = show_common,
               text.random = p_text
  )
}

#' Plot correlation between continuous drug and omic data
#'
#' @description Creates a scatter plot with correlation statistics for a single drug-omic pair
#' @param omic_values Vector of omic feature values
#' @param drug_values Vector of drug response values
#' @param study_name Name of the study for plot title
#' @return A ggplot2 object with scatter plot and correlation statistics
#' @export
plotContinuousDrugOmic <- function(omic_values, drug_values, study_name) {
  # Combine data into dataframe
  cor_df <- data.frame(
    genes = omic_values,
    drugs = drug_values
  )

  # Create scatter plot with correlation statistics
  ggscatter(cor_df, x = "genes", y = "drugs", alpha = 0.2) +
    stat_cor(size = 6, method = "spearman") +
    stat_smooth(formula = y ~ x, method = "lm") +
    theme_bw() +
    theme(
      axis.title = element_blank(),
      title = element_text(size = 15, face = "bold"),
      axis.text = element_text(size = 12)
    ) +
    ggtitle(study_name)
}

#' Plot all continuous drug-omic pairs
#'
#' @description Creates and combines plots for all continuous drug-omic pairs
#' @param pairs_list List of paired drug-omic datasets
#' @return A combined plot with all drug-omic correlations or NULL if no valid pairs
#' @export
plotAllContinuousDrugOmic <- function(pairs_list) {
  # Initialize list to store plots
  p_list <- list()

  # Create plot for each pair
  for (i in seq_along(pairs_list)) {

    # Try to create the plot, continue if error
      omic_sel <- pairs_list[[i]]$omic
      drug_sel <- pairs_list[[i]]$drug

      # Ensure adequate data for plotting
      if (length(omic_sel) < 3 || length(drug_sel) < 3) next

      # Create plot and add to list
      p_list[[i]] <- plotContinuousDrugOmic(omic_sel, drug_sel, names(pairs_list)[i])
  }

  # Remove NULL entries from list
  p_list <- p_list[!sapply(p_list, is.null)]

  # Combine plots using patchwork if plots exist
  if (length(p_list) > 0) {
    if (length(p_list) < 3){
      return(wrap_plots(p_list, ncol = length(p_list)))
    } else {
      return(wrap_plots(p_list, ncol = 3))
    }
  } else {
    return(NULL)
  }
}

#' Plot drug response by discrete omic feature
#'
#' @description Creates a boxplot comparing drug response between samples with and without a discrete omic feature
#' @param yes_values Drug response values for samples with the feature
#' @param no_values Drug response values for samples without the feature
#' @param study_name Name of the study for plot title
#' @return A ggplot2 object with boxplot and statistical test
#' @export
plotDiscreteDrugOmic <- function(yes_values, no_values, study_name) {
  # Combine data into dataframe
  box_df <- data.frame(
    drugs = c(no_values, yes_values),
    events = rep(c("no", "yes"), times = c(length(no_values), length(yes_values)))
  )

  # Create boxplot with statistical test
  ggboxplot(data = box_df, x = "events", y = "drugs",
            fill = "events", palette = c("#BEBADAFF", "#FB8072FF"),
            add = "jitter", add.params = list(alpha = 0.15)) +
    stat_compare_means(size = 6, label.x = 0.8,
                       label.y = (max(box_df$drugs) - max(box_df$drugs)/8),
                       label = "p.format") +
    theme_bw() +
    theme(
      axis.title = element_blank(),
      title = element_text(size = 15, face = "bold"),
      axis.text = element_text(size = 12),
      legend.position = "none"
    ) +
    coord_cartesian(ylim = c(NA, max(box_df$drugs) + max(box_df$drugs)/20)) +
    ggtitle(study_name)
}

#' Plot all discrete drug-omic pairs
#'
#' @description Creates and combines plots for all discrete drug-omic pairs
#' @param pairs_list List of paired drug-omic datasets with yes/no groups
#' @return A combined plot with all discrete drug-omic comparisons or NULL if no valid pairs
#' @export
plotAllDiscreteDrugOmic <- function(pairs_list) {
  # Initialize list to store plots
  p_list <- list()

  # Create plot for each pair
  for (i in seq_along(pairs_list)) {

    # Try to create the plot, continue if error
    yes_drugs <- pairs_list[[i]]$yes
    no_drugs <- pairs_list[[i]]$no

    # Ensure adequate data for plotting
    if (length(yes_drugs) < 3 || length(no_drugs) < 3) next

    # Create plot and add to list
    p_list[[i]] <- plotDiscreteDrugOmic(yes_drugs, no_drugs, names(pairs_list)[i])
  }

  # Remove NULL entries from list
  p_list <- p_list[!sapply(p_list, is.null)]

  # Combine plots using patchwork if plots exist
  if (length(p_list) > 0) {
    return(wrap_plots(p_list, ncol = 3))
  } else {
    return(NULL)
  }
}

#' Create plot with common axis labels
#'
#' @description Creates a plot with common axis labels for multiple subplots
#' @param p A patchwork object containing multiple plots
#' @param x_title Common x-axis title
#' @param y_title Common y-axis title
#' @return A function that generates the plot when called
#' @export
createPlotWithCommonAxes <- function(p, x_title = "Common X-Axis Title",
                                     y_title = "Common Y-Axis Title") {
  # Create a function that will generate the plot when called
  function() {
    # Convert patchwork to a grob
    p_grob <- patchworkGrob(p)

    # Create a new plotting area
    grid.newpage()

    # Draw the patchwork
    grid.draw(p_grob)

    # Add common x-axis title
    grid.text(x_title,
              x = 0.5, y = 0.02,
              gp = gpar(fontsize = 18, fontface = "bold"))

    # Add common y-axis title (rotated)
    grid.text(y_title,
              x = 0.01, y = 0.5,
              rot = 90,
              gp = gpar(fontsize = 18, fontface = "bold"))

    # Return the grob for potential further use
    invisible(p_grob)
  }
}

# Main Analysis Function ----

#' Analyze drug-omic pair associations using DromaSet objects
#'
#' @description Main function for analyzing associations between a drug and an omic feature using DromaSet or MultiDromaSet objects
#' @param dromaset_object Either a DromaSet or MultiDromaSet object
#' @param select_omics_type Type of omics data to analyze (e.g., "mRNA", "mutation_gene")
#' @param select_omics Name of the specific omics feature
#' @param select_drugs Name of the drug to analyze
#' @param data_type Filter by data type ("all", "CellLine", "PDO", "PDC", "PDX")
#' @param tumor_type Filter by tumor type ("all" or specific tumor types)
#' @param overlap_only For MultiDromaSet, whether to use only overlapping samples (default: FALSE)
#' @param merged_enabled Logical, whether to create a merged dataset from all studies
#' @param meta_enabled Logical, whether to perform meta-analysis
#' @return A list containing plot, meta-analysis results, and data
#' @export
#' @examples
#' \dontrun{
#' # Using DromaSet
#' gCSI <- createDromaSetFromDatabase("gCSI", "path/to/droma.sqlite")
#' result <- analyzeDrugOmicPair(gCSI, "mRNA", "ABCB1", "Paclitaxel")
#'
#' # Using MultiDromaSet
#' multi_set <- createMultiDromaSetFromDatabase(c("gCSI", "CCLE"), "path/to/droma.sqlite")
#' result <- analyzeDrugOmicPair(multi_set, "mRNA", "ABCB1", "Paclitaxel")
#' }
analyzeDrugOmicPair <- function(dromaset_object, select_omics_type, select_omics,
                                select_drugs,
                                data_type = "all", tumor_type = "all",
                                overlap_only = FALSE,
                                merged_enabled = TRUE,
                                meta_enabled = TRUE){

  # Validate input object
  if (!inherits(dromaset_object, c("DromaSet", "MultiDromaSet"))) {
    stop("Input must be a DromaSet or MultiDromaSet object from DROMA.Set package")
  }

  # Load and extract drug data
  if (inherits(dromaset_object, "DromaSet")) {
    # Single DromaSet
    myDrugs <- loadTreatmentResponseNormalized(dromaset_object,
                                    drugs = select_drugs,
                                    data_type = data_type,
                                    tumor_type = tumor_type,
                                    return_data = TRUE)

    # Convert matrix to list format for compatibility
    if (is.matrix(myDrugs) && select_drugs %in% rownames(myDrugs)) {
      drug_vector <- as.numeric(myDrugs[select_drugs, ])
      names(drug_vector) <- colnames(myDrugs)
      myDrugs <- list()
      myDrugs[[dromaset_object@name]] <- drug_vector[!is.na(drug_vector)]
    }

  } else {
    # MultiDromaSet
    myDrugs <- loadMultiProjectTreatmentResponseNormalized(dromaset_object,
                                                drugs = select_drugs,
                                                overlap_only = overlap_only,
                                                data_type = data_type,
                                                tumor_type = tumor_type)

    # Extract specific drug from each project
    myDrugs <- lapply(myDrugs, function(drug_matrix) {
      if (is.matrix(drug_matrix) && select_drugs %in% rownames(drug_matrix)) {
        drug_vector <- as.numeric(drug_matrix[select_drugs, ])
        names(drug_vector) <- colnames(drug_matrix)
        return(drug_vector[!is.na(drug_vector)])
      }
      return(NULL)
    })

    # Remove NULL entries
    myDrugs <- myDrugs[!sapply(myDrugs, is.null)]
  }

  # Load and extract omics data
  if (inherits(dromaset_object, "DromaSet")) {
    # Single DromaSet
    if (select_omics_type %in% c("drug", "drug_raw")) {
      # This is actually another drug, use treatment response
      myOmics <- loadTreatmentResponseNormalized(dromaset_object,
                                      drugs = select_omics,
                                      data_type = data_type,
                                      tumor_type = tumor_type,
                                      return_data = TRUE)

      if (is.matrix(myOmics) && select_omics %in% rownames(myOmics)) {
        omics_vector <- as.numeric(myOmics[select_omics, ])
        names(omics_vector) <- colnames(myOmics)
        myOmics <- list()
        myOmics[[dromaset_object@name]] <- omics_vector[!is.na(omics_vector)]
      }
    } else {
      # Molecular profile data
      myOmics <- loadMolecularProfilesNormalized(dromaset_object,
                                      molecular_type = select_omics_type,
                                      features = select_omics,
                                      data_type = data_type,
                                      tumor_type = tumor_type,
                                      return_data = TRUE)

      # Handle different data types
      if (select_omics_type %in% c("mRNA", "meth", "proteinrppa", "cnv", "proteinms")) {
        # Continuous data
        if (is.matrix(myOmics) && select_omics %in% rownames(myOmics)) {
          omics_vector <- as.numeric(myOmics[select_omics, ])
          names(omics_vector) <- colnames(myOmics)
          myOmics <- list()
          myOmics[[dromaset_object@name]] <- omics_vector[!is.na(omics_vector)]
        }
      } else {
        # Discrete data (mutations, fusions)
        if (is.data.frame(myOmics)) {
          # Extract sample IDs where the feature is present
          if ("cells" %in% colnames(myOmics)) {
            sample_ids <- myOmics$cells[myOmics$genes == select_omics]
          } else if ("samples" %in% colnames(myOmics)) {
            sample_ids <- myOmics$samples[myOmics$genes == select_omics]
          } else {
            sample_ids <- character(0)
          }
          myOmics <- list()
          myOmics[[dromaset_object@name]] <- sample_ids
        }
      }
    }

  } else {
    # MultiDromaSet
    if (select_omics_type %in% c("drug", "drug_raw")) {
      # This is actually another drug, use treatment response
      myOmics <- loadMultiProjectTreatmentResponseNormalized(dromaset_object,
                                                  drugs = select_omics,
                                                  overlap_only = overlap_only,
                                                  data_type = data_type,
                                                  tumor_type = tumor_type)

      # Extract specific drug from each project
      myOmics <- lapply(myOmics, function(drug_matrix) {
        if (is.matrix(drug_matrix) && select_omics %in% rownames(drug_matrix)) {
          drug_vector <- as.numeric(drug_matrix[select_omics, ])
          names(drug_vector) <- colnames(drug_matrix)
          return(drug_vector[!is.na(drug_vector)])
        }
        return(NULL)
      })
    } else {
      # Molecular profile data
      myOmics <- loadMultiProjectMolecularProfilesNormalized(dromaset_object,
                                                  molecular_type = select_omics_type,
                                                  features = select_omics,
                                                  overlap_only = overlap_only,
                                                  data_type = data_type,
                                                  tumor_type = tumor_type)

      # Handle different data types
      if (select_omics_type %in% c("mRNA", "meth", "proteinrppa", "cnv", "proteinms")) {
        # Continuous data
        myOmics <- lapply(myOmics, function(omics_matrix) {
          if (is.matrix(omics_matrix) && select_omics %in% rownames(omics_matrix)) {
            omics_vector <- as.numeric(omics_matrix[select_omics, ])
            names(omics_vector) <- colnames(omics_matrix)
            return(omics_vector[!is.na(omics_vector)])
          }
          return(NULL)
        })
      } else {
        # Discrete data (mutations, fusions)
        myOmics <- lapply(myOmics, function(omics_df) {
          if (is.data.frame(omics_df)) {
            # Extract sample IDs where the feature is present
            if ("cells" %in% colnames(omics_df)) {
              sample_ids <- omics_df$cells[omics_df$genes == select_omics]
            } else if ("samples" %in% colnames(omics_df)) {
              sample_ids <- omics_df$samples[omics_df$genes == select_omics]
            } else {
              sample_ids <- character(0)
            }
            return(sample_ids)
          }
          return(NULL)
        })
      }
    }

    # Remove NULL entries
    myOmics <- myOmics[!sapply(myOmics, is.null)]
  }

  # Check if we have data
  if (length(myDrugs) == 0 || length(myOmics) == 0) {
    stop("No data found for the specified drug-omics pair")
  }

  # Initialize result list
  result <- list()

  # Handle continuous omics data
  if(select_omics_type %in% c("mRNA", "meth", "proteinrppa", "cnv", "proteinms", "drug")){
    # Pair data
    myPairs <- pairDrugOmic(myOmics, myDrugs, merged = merged_enabled)

    # Create plots
    result$plot <- plotAllContinuousDrugOmic(myPairs)

    # Perform meta-analysis
    if(meta_enabled){
      meta_result <- analyzeContinuousDrugOmic(myPairs)
      if (!is.null(meta_result)) {
        result$meta <- meta_result
      }
    }

    # Store data
    result$data <- myPairs
  } else {
    # Pair data
    myPairs <- pairDiscreteDrugOmic(myOmics, myDrugs, merged = merged_enabled)

    # Create plots
    result$plot <- plotAllDiscreteDrugOmic(myPairs)

    # Perform meta-analysis
    if(meta_enabled){
      meta_result <- analyzeDiscreteDrugOmic(myPairs)
      if (!is.null(meta_result)) {
        result$meta <- meta_result
      }
    }

    # Store data
    result$data <- myPairs
  }

  # Return results if there's a plot
  if (is.null(result$plot)) {
    return(list())
  } else {
    return(result)
  }
}




================================================
FILE: R/FuncStat.R
================================================



================================================
FILE: R/FuncZscoreWhole.R
================================================
#' Z-score normalization for omics data
#'
#' @description Apply Z-score normalization to omics data at the gene level
#' @param mat A matrix or data frame with genes in rows and samples in columns
#' @return A normalized matrix with Z-scores
#' @export
zscoreNormalize <- function(mat) {
  # Apply z-score normalization to each row (gene)
  normalized <- t(scale(t(mat)))
  # Handle any potential NaN values (e.g., if SD was 0)
  normalized[is.nan(normalized)] <- 0
  return(normalized)
}



================================================
FILE: R/theme_utils.R
================================================
#' DROMA Color Palettes and Visualization Themes
#'
#' @description This file contains color palettes and theme settings for DROMA package visualizations.
#'

#' Bright color palette with 26 distinct colors
#' 
#' @description A palette of 26 bright, distinct colors for visualization
#' @export
bright_palette_26 <- c(
  "#FF5733", # Bright red-orange
  "#33C4FF", # Bright sky blue
  "#FF33E9", # Bright pink
  "#33FF57", # Bright green
  "#FFD133", # Bright yellow
  "#8B33FF", # Bright purple
  "#FF8B33", # Bright orange
  "#33FFC4", # Bright teal
  "#FF3355", # Bright red
  "#33FFED", # Bright cyan
  "#C433FF", # Bright violet
  "#BBFF33", # Bright lime
  "#FF33BB", # Bright magenta
  "#33FFB2", # Bright mint
  "#3357FF", # Bright blue
  "#FF9933", # Bright amber
  "#33FF78", # Bright seafoam
  "#ED33FF", # Bright fuchsia
  "#57FF33", # Bright chartreuse
  "#FF33C4", # Bright hot pink
  "#33A5FF", # Bright azure
  "#FFB233", # Bright gold
  "#3378FF", # Bright royal blue
  "#FF5733", # Bright vermilion
  "#33FF9E", # Bright turquoise
  "#D6FF33"  # Bright yellow-green
)



================================================
FILE: .cursor/rules/droma.mdc
================================================
---
description: 
globs: 
alwaysApply: true
---
# DROMA.R Package Structure

DROMA.R is an R package that provides advanced analysis functions for drug-omics associations using DromaSet and MultiDromaSet objects from the DROMA.Set package. It supports meta-analysis across multiple datasets, visualization of results, and batch processing of features.

## Key Modules

- `FuncDrugOmicPair.R`: Functions for analyzing drug-omics relationships using DromaSet objects
- `FuncBatchFeature.R`: Functions for batch analysis of features across multiple datasets
- `FuncDrugFeature.R`: Functions for drug data processing and visualization
- `FuncZscoreWhole.R`: Functions for z-score normalization
- `theme_utils.R`: Color palettes and visualization themes for consistent plotting

## Core Functions

### Data Management (via DROMA.Set)
- `createDromaSetFromDatabase()`: Creates DromaSet objects from database
- `createMultiDromaSetFromDatabase()`: Creates MultiDromaSet objects for cross-project analysis
- `loadTreatmentResponse()`: Loads drug response data from DromaSet objects
- `loadMolecularProfiles()`: Loads omics data from DromaSet objects

### Analysis Functions
- `analyzeDrugOmicPair(dromaset_object, ...)`: Analyzes association between drug response and omics feature using DromaSet objects
- `batchFindSignificantFeatures(dromaset_object, ...)`: Performs batch analysis of features using DromaSet objects
- `pairContinuousFeatures()`: Pairs continuous feature data across datasets
- `processDrugData(dromaset_object, ...)`: Processes drug sensitivity data from DromaSet objects
- `getDrugSensitivityData(dromaset_object, ...)`: Retrieves comprehensive drug sensitivity data

### Visualization
- `createForestPlot()`: Creates forest plots for meta-analysis results
- `plotMetaVolcano()`: Creates volcano plots for batch analysis results
- `plotContinuousComparison()`: Creates scatter plots for continuous data relationships
- `plotCategoryComparison()`: Creates boxplots for categorical comparisons
- `bright_palette_26`: Pre-defined palette of 26 distinct colors for consistent visualization

## Common Workflows

1. Create DromaSet objects: `createDromaSetFromDatabase()` or `createMultiDromaSetFromDatabase()`
2. Analyze drug-omics relationships: `analyzeDrugOmicPair(dromaset_object, "mRNA", "ABCB1", "Paclitaxel")`
3. Perform batch analysis: `batchFindSignificantFeatures(dromaset_object, "drug", "Paclitaxel", "mRNA")`
4. Visualize results with appropriate plotting functions using consistent color themes
5. Use MultiDromaSet for cross-project meta-analysis

## Data Types

- Drug response data: Accessed via `loadTreatmentResponse(dromaset_object, drugs = "drug_name")`
- mRNA expression: Accessed via `loadMolecularProfiles(dromaset_object, molecular_type = "mRNA")`
- Mutations: Accessed via `loadMolecularProfiles(dromaset_object, molecular_type = "mutation_gene")`
- Methylation: Accessed via `loadMolecularProfiles(dromaset_object, molecular_type = "meth")`
- Protein expression: Accessed via `loadMolecularProfiles(dromaset_object, molecular_type = "proteinrppa")`
- Copy number variation: Accessed via `loadMolecularProfiles(dromaset_object, molecular_type = "cnv")`
- Fusion data: Accessed via `loadMolecularProfiles(dromaset_object, molecular_type = "fusion")`

## Best Practices

1. Always start by creating DromaSet objects with `createDromaSetFromDatabase()` or `createMultiDromaSetFromDatabase()`
2. Use MultiDromaSet for cross-project meta-analysis to increase statistical power
3. Use batch processing for analyzing multiple features efficiently
4. When analyzing drug-omics pairs, check for sufficient sample sizes
5. Apply data type and tumor type filtering for targeted analyses
6. You may **Use `overlap_only = TRUE`** when loading cross-project data to focus on same samples
7. Apply consistent visualization themes using the provided color palettes
8. Leverage parallel processing (`cores > 1`) for large-scale batch analyses

