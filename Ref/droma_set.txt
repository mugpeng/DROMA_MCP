================================================
FILE: README.md
================================================
# DROMA_Set: Drug Response and Omics Multi-project Analysis Set

[![R](https://img.shields.io/badge/R-%3E%3D4.0.0-blue.svg)](https://www.r-project.org/)
[![License: mpl-2-0](https://img.shields.io/badge/MPL-2.0-yellow.svg)](https://opensource.org/licenses/mpl-2-0)

## Overview

**DROMA_Set** is a comprehensive R package for managing and analyzing drug response and omics data across multiple projects. It provides a robust framework for handling complex multi-omics datasets with integrated drug sensitivity information, enabling seamless cross-project comparisons and analyses.

### Key Features

- **🔬 Multi-omics Data Management**: Support for various molecular profile types (mRNA, CNV, mutations, methylation, proteomics)
- **💊 Drug Response Integration**: Comprehensive treatment response data handling and analysis
- **🔗 Cross-Project Analysis**: Advanced tools for comparing and analyzing data across multiple projects
- **📊 Sample Overlap Detection**: Automatic identification and analysis of overlapping samples between projects
- **🗄️ Database Integration**: Robust SQLite database connectivity with efficient data storage and retrieval
- **📈 Flexible Data Loading**: Smart data loading with filtering by data type, tumor type, and specific features
- **🎯 Metadata Management**: Comprehensive sample and treatment metadata handling with ProjectID tracking

## Installation

### From GitHub (Recommended)

```r
# Install devtools if you haven't already
if (!requireNamespace("devtools", quietly = TRUE)) {
    install.packages("devtools")
}

# Install DROMA_Set
devtools::install_github("mugpeng/DROMA_Set")
```

### Dependencies

The package requires the following R packages:
- `DBI` (>= 1.1.0)
- `RSQLite` (>= 2.2.0)
- `methods`

These will be automatically installed when you install DROMA_Set.

## Quick Start

### 1. Load the Package

```r
library(DROMA.Set)
```

### 2. Connect to Database

```r
# Connect to your DROMA database
connectDROMADatabase("path/to/your/droma.sqlite")

# List available projects
projects <- listDROMAProjects()
print(projects)
```

### 3. Create DromaSet Objects

```r
# Create a single DromaSet for one project
gCSI <- createDromaSetFromDatabase("gCSI", "path/to/droma.sqlite")

# Create a MultiDromaSet for multiple projects
multi_set <- createMultiDromaSetFromDatabase(
    project_names = c("gCSI", "CCLE"),
    db_path = "path/to/droma.sqlite"
)
```

### 4. Load and Analyze Data

```r
# Load molecular profiles
gCSI <- loadMolecularProfiles(gCSI, molecular_type = "mRNA", 
                             features = c("BRCA1", "BRCA2", "TP53"))

# Load treatment response data
gCSI <- loadTreatmentResponse(gCSI, drugs = c("Tamoxifen", "Cisplatin"))

# Cross-project molecular analysis
mRNA_data <- loadMultiProjectMolecularProfiles(multi_set, 
                                              molecular_type = "mRNA",
                                              overlap_only = FLASE)

# Cross-project treatment response analysis
drug_data <- loadMultiProjectTreatmentResponse(multi_set,
                                              drugs = c("Tamoxifen", "Cisplatin"),
                                              overlap_only = FLASE)
```

## Core Classes

### DromaSet Class

The `DromaSet` class represents a single project's drug response and omics data:

```r
# Create DromaSet
dataset <- createDromaSetFromDatabase("project_name", "database.sqlite")

# Load all molecular profiles
dataset <- loadMolecularProfiles(dataset, molecular_type = "all")

# Check available data types
availableMolecularProfiles(dataset)
availableTreatmentResponses(dataset)
```

**Key Methods:**
- `loadMolecularProfiles()`: Load omics data (mRNA, CNV, mutations, etc.)
- `loadTreatmentResponse()`: Load drug sensitivity data
- `availableMolecularProfiles()`: List available molecular data types
- `availableTreatmentResponses()`: List available treatment response types

### MultiDromaSet Class

The `MultiDromaSet` class manages multiple projects for cross-project analysis:

```r
# Create MultiDromaSet
multi_set <- createMultiDromaSetFromDatabase(c("gCSI", "CCLE"), "database.sqlite")

# Find overlapping samples
overlap_info <- getOverlappingSamples(multi_set)

# Load molecular data across projects
mRNA_data <- loadMultiProjectMolecularProfiles(multi_set, 
                                              molecular_type = "mRNA")

# Load treatment response data across projects
drug_data <- loadMultiProjectTreatmentResponse(multi_set,
                                              drugs = c("Tamoxifen", "Cisplatin"))
```

**Key Methods:**
- `getOverlappingSamples()`: Identify samples present in multiple projects
- `loadMultiProjectMolecularProfiles()`: Load molecular data across multiple projects
- `loadMultiProjectTreatmentResponse()`: Load treatment response data across multiple projects
- `getDromaSet()`: Extract individual DromaSet from MultiDromaSet
- `availableProjects()`: List available projects

## Advanced Features

### 1. Load All Molecular Profiles

```r
# Load all available molecular profile types
all_data <- loadMolecularProfiles(dataset, molecular_type = "all")

# Cross-project loading of all molecular types
all_cross_data <- loadMultiProjectMolecularProfiles(multi_set,
                                                   molecular_type = "all")
```

### 2. Sample and Data Filtering

```r
# Filter by data type and tumor type
filtered_data <- loadMolecularProfiles(dataset,
                                      molecular_type = "mRNA",
                                      data_type = "CellLine",
                                      tumor_type = "breast cancer")

# Load specific features and samples
specific_data <- loadMolecularProfiles(dataset,
                                      molecular_type = "mRNA",
                                      features = c("BRCA1", "TP53"),
                                      samples = c("sample1", "sample2"))

# Cross-project filtering by data type and tumor type
filtered_cross_data <- loadMultiProjectMolecularProfiles(multi_set,
                                                        molecular_type = "mRNA",
                                                        data_type = "CellLine",
                                                        tumor_type = "breast cancer",
                                                        overlap_only = FLASE)
```

### 3. Database Management

```r
# Connect to database
connectDROMADatabase("droma.sqlite")

# Add new data to database
updateDROMADatabase(expression_matrix, "new_project_mRNA")

# List all tables
tables <- listDROMADatabaseTables()

# Close connection
closeDROMADatabase()
```

### 4. Cross-Project Analysis Workflow

```r
# 1. Create MultiDromaSet
multi_set <- createMultiDromaSetFromDatabase(c("gCSI", "CCLE"))

# 2. Find overlapping samples
overlaps <- getOverlappingSamples(multi_set)
cat("Found", overlaps$overlap_count, "overlapping samples")

# 3. Load molecular data for overlapping samples
mRNA_data <- loadMultiProjectMolecularProfiles(multi_set,
                                              molecular_type = "mRNA",
                                              features = c("BRCA1", "BRCA2"),
                                              overlap_only = FLASE,
                                              data_type = "CellLine")

# 4. Load drug response data for overlapping samples
drug_data <- loadMultiProjectTreatmentResponse(multi_set,
                                              drugs = c("Tamoxifen", "Cisplatin"),
                                              overlap_only = FLASE,
                                              data_type = "CellLine")

# 5. Perform correlation analysis
for (project in names(mRNA_data)) {
    if (project %in% names(drug_data)) {
        # Analyze correlations between gene expression and drug response
        # Your analysis code here
    }
}
```

## Data Types Supported

### Molecular Profiles
- **mRNA**: Gene expression data
- **cnv**: Copy number variation data
- **mutation_gene**: Gene-level mutation data
- **mutation_site**: Site-specific mutation data
- **fusion**: Gene fusion data
- **meth**: DNA methylation data
- **proteinrppa**: Reverse-phase protein array data
- **proteinms**: Mass spectrometry proteomics data

### Treatment Response
- **drug**: Drug sensitivity/response data
- **drug_raw**: Raw drug response measurements

## Database Structure

The DROMA database uses a standardized table naming convention:
- `{project}_{datatype}`: Data tables (e.g., `gCSI_mRNA`, `CCLE_drug`)
- `sample_anno`: Sample metadata with ProjectID tracking
- `drug_anno`: Drug/treatment metadata with ProjectID tracking
- `projects`: Project summary information

## Examples

Comprehensive examples are provided in the `examples/` directory:

- `examples/produce_dromaset.R`: Basic DromaSet usage
- `examples/produce_multidromaset.R`: MultiDromaSet cross-project analysis
- `examples/produce_droma_database.R`: Database creation and management

## Performance Tips

1. You may **Use `overlap_only = TRUE`** when loading cross-project data to focus on same samples
2. **Specify `features` parameter** to load only genes/drugs of interest
3. **Use `return_data = TRUE`** when you only need the data without updating the object
4. **Filter by `data_type` and `tumor_type`** to reduce data loading time and focus on specific sample types
5. **Load molecular profiles incrementally** rather than using `molecular_type = "all"` for large datasets

## Contributing

We welcome contributions! Please see our contributing guidelines:

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## Citation

If you use DROMA_Set in your research, please cite:

```
Zhong, P.Y. (2024). DROMA_Set: Drug Response and Omics Multi-project Analysis Set. 
R package version 0.9.0. https://github.com/mugpeng/DROMA_Set
```

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Support

- 📧 **Email**: yc47680@um.edu.mo
- 🐛 **Issues**: [GitHub Issues](https://github.com/mugpeng/DROMA_Set/issues)
- 📖 **Documentation**: [Package Documentation](https://mugpeng.github.io/DROMA_Set/)

## Changelog

### Version 0.9.0
- Initial release
- DromaSet and MultiDromaSet classes
- Database integration and management
- Cross-project analysis capabilities
- Comprehensive molecular profile support
- Sample overlap detection and analysis
- Enhanced metadata management with ProjectID tracking
- Support for loading all molecular profile types with `molecular_type = "all"`
- Split cross-project data loading into specialized functions:
  - `loadMultiProjectMolecularProfiles()` for molecular data
  - `loadMultiProjectTreatmentResponse()` for treatment response data
- Added `data_type` and `tumor_type` filtering parameters for enhanced sample selection

---

**DROMA_Set** - Empowering multi-project drug response and omics analysis 🧬💊



================================================
FILE: .Rbuildignore
================================================
^.*\.Rproj$
^\.Rproj\.user$
^archive/
^data/





================================================
FILE: R/DROMA_SQLManager.R
================================================
#' Connect to DROMA Database
#'
#' @description Establishes a connection to the DROMA SQLite database
#' @param db_path Path to the SQLite database file
#' @return A database connection object
#' @export
connectDROMADatabase <- function(db_path = file.path(path.expand("sql_db"), "droma.sqlite")) {
  if (!requireNamespace("RSQLite", quietly = TRUE) ||
      !requireNamespace("DBI", quietly = TRUE)) {
    stop("Packages 'RSQLite' and 'DBI' are required. Please install them with install.packages(c('RSQLite', 'DBI'))")
  }

  if (!file.exists(db_path)) {
    stop("Database file not found. Create the database first with createDROMADatabase()")
  }

  con <- DBI::dbConnect(RSQLite::SQLite(), db_path)
  message("Connected to DROMA database at ", db_path)

  # Store the connection in the package environment
  assign("droma_db_connection", con, envir = .GlobalEnv)

  # Register an exit handler to close the connection when R exits
  reg.finalizer(.GlobalEnv, function(e) {
    if (exists("droma_db_connection", envir = e) &&
        inherits(get("droma_db_connection", envir = e), "DBIConnection")) {
      DBI::dbDisconnect(get("droma_db_connection", envir = e))
    }
  }, onexit = TRUE)

  return(con)
}

#' Update DROMA Database with New Object
#'
#' @description Adds or updates a table in the DROMA database with a new object
#' @param obj The object to add to the database (matrix or data.frame)
#' @param table_name The name to use for the table in the database
#' @param overwrite Logical, whether to overwrite if table already exists (default: FALSE)
#' @param connection Optional database connection object. If NULL, uses global connection
#' @return Invisibly returns TRUE if successful
#' @export
#' @examples
#' \dontrun{
#' # Connect to database
#' con <- connectDROMADatabase("path/to/droma.sqlite")
#'
#' # Create a matrix of gene expression data
#' expr_data <- matrix(rnorm(100), nrow = 10, ncol = 10)
#' rownames(expr_data) <- paste0("gene", 1:10)
#' colnames(expr_data) <- paste0("sample", 1:10)
#'
#' # Add to database as "myproject_mRNA"
#' updateDROMADatabase(expr_data, "myproject_mRNA", overwrite = TRUE)
#' }
updateDROMADatabase <- function(obj, table_name, overwrite = FALSE, connection = NULL) {
  if (!requireNamespace("DBI", quietly = TRUE) ||
      !requireNamespace("RSQLite", quietly = TRUE)) {
    stop("Packages 'DBI' and 'RSQLite' are required. Please install them with install.packages(c('DBI', 'RSQLite'))")
  }

  # Get connection from global environment if not provided
  if (is.null(connection)) {
    if (!exists("droma_db_connection", envir = .GlobalEnv)) {
      stop("No database connection found. Connect first with connectDROMADatabase()")
    }
    connection <- get("droma_db_connection", envir = .GlobalEnv)
  }

  # Check if table already exists
  all_tables <- DBI::dbListTables(connection)
  if (table_name %in% all_tables && !overwrite) {
    stop("Table '", table_name, "' already exists. Set overwrite = TRUE to replace it.")
  } else if (table_name %in% all_tables && overwrite) {
    message("Overwriting existing table '", table_name, "'")
  }

  # Process the object based on its type
  if (is.matrix(obj)) {
    # Convert matrix to data frame with feature_id column
    df <- as.data.frame(obj)
    df$feature_id <- rownames(df)

    # Write to database
    DBI::dbWriteTable(connection, table_name, df, overwrite = TRUE)

    # Create index on feature_id for faster lookups
    DBI::dbExecute(connection, paste0("CREATE INDEX IF NOT EXISTS idx_", table_name, "_feature_id ON ",
                                     table_name, " (feature_id)"))

    message("Added matrix to database as '", table_name, "' with ", nrow(df), " rows and ",
            ncol(df) - 1, " columns")
  } else if (is.data.frame(obj)) {
    obj <- as.data.frame(obj)
    # Check if the data frame has rownames and preserve them
    if (!is.null(rownames(obj)) && !all(rownames(obj) == seq_len(nrow(obj)))) {
      # If data frame has meaningful rownames, add them as feature_id column
      df <- obj
      df$feature_id <- rownames(df)

      # Write to database
      DBI::dbWriteTable(connection, table_name, df, overwrite = TRUE)

      # Create index on feature_id for faster lookups
      DBI::dbExecute(connection, paste0("CREATE INDEX IF NOT EXISTS idx_", table_name, "_feature_id ON ",
                                       table_name, " (feature_id)"))

      message("Added data frame to database as '", table_name, "' with ", nrow(df), " rows and ",
              ncol(df) - 1, " columns")
    } else {
      # If no meaningful rownames, write directly
      DBI::dbWriteTable(connection, table_name, obj, overwrite = TRUE)
      message("Added data frame to database as '", table_name, "' with ", nrow(obj), " rows and ",
              ncol(obj), " columns")
    }
  } else {
    stop("Object must be a matrix or data frame")
  }

  # Update projects table if it exists
  if ("projects" %in% all_tables) {
    # Extract project name from table name
    parts <- strsplit(table_name, "_")[[1]]
    if (length(parts) >= 2) {
      project_name <- parts[1]
      data_type <- paste(parts[-1], collapse = "_")

      # Check if project exists in projects table
      projects_df <- DBI::dbReadTable(connection, "projects")

      if (project_name %in% projects_df$project_name) {
        # Update existing project entry
        project_row <- projects_df[projects_df$project_name == project_name, ]

        # Update data_types field
        current_types <- unlist(strsplit(project_row$data_types, ","))
        if (!data_type %in% current_types) {
          new_types <- sort(c(current_types, data_type))
          project_row$data_types <- paste(new_types, collapse = ",")

          # Update the row in the projects table
          DBI::dbExecute(connection, paste0(
            "UPDATE projects SET data_types = '", project_row$data_types,
            "' WHERE project_name = '", project_name, "'"
          ))

          message("Updated project '", project_name, "' with new data type '", data_type, "'")
        }
      } else {
        # Create new project entry
        new_project <- data.frame(
          project_name = project_name,
          dataset_type = NA_character_,
          data_types = data_type,
          sample_count = length(setdiff(colnames(obj), "feature_id")),
          drug_count = if(data_type == "drug") nrow(obj) else 0,
          stringsAsFactors = FALSE
        )

        # Add to projects table
        DBI::dbWriteTable(connection, "projects", new_project, append = TRUE)
        message("Added new project '", project_name, "' to projects table")
      }
    }
  }

  invisible(TRUE)
}

#' Retrieve Feature Data from DROMA Database
#'
#' @description Fetches specific feature data from the DROMA database based on selection criteria
#' @param select_feas_type The type of feature to select (e.g., "mRNA", "cnv", "drug")
#' @param select_feas The specific feature to select within the feature type
#' @param data_sources Vector of data sources to select from (e.g., c("ccle", "gdsc"))
#' @param data_type Filter by data type: "all" (default), "CellLine", "PDO", "PDC", or "PDX"
#' @param tumor_type Filter by tumor type: "all" (default) or specific tumor type
#' @param connection Optional database connection object. If NULL, uses global connection.
#' @return A list of selected features from specified data sources
#' @export
#' @note This function is provided for backward compatibility. For new code, consider
#' using the DromaSet object approach instead.
getFeatureFromDatabase <- function(select_feas_type, select_feas,
                                 data_sources = "all",
                                 data_type = "all", tumor_type = "all",
                                 connection = NULL) {
  if (!requireNamespace("DBI", quietly = TRUE)) {
    stop("Package 'DBI' is required. Please install with install.packages('DBI')")
  }

  # Get connection from global environment if not provided
  if (is.null(connection)) {
    if (!exists("droma_db_connection", envir = .GlobalEnv)) {
      stop("No database connection found. Connect first with connectDROMADatabase()")
    }
    connection <- get("droma_db_connection", envir = .GlobalEnv)
  }

  # Get data source tables that match the feature type
  all_tables <- DBI::dbListTables(connection)
  pattern <- paste0("_", select_feas_type, "$")
  feature_tables <- grep(pattern, all_tables, value = TRUE)

  if (length(feature_tables) == 0) {
    stop("No tables found for feature type: ", select_feas_type)
  }

  # Filter by data sources if specified
  if (!identical(data_sources, "all")) {
    feature_tables <- grep(paste0("^(", paste(data_sources, collapse = "|"), ")_"),
                           feature_tables, value = TRUE)
  }

  if (length(feature_tables) == 0) {
    stop("No matching tables found for the specified data sources")
  }

  # Get sample IDs from sample_anno based on data_type and tumor_type
  filtered_samples <- NULL
  if (data_type != "all" || tumor_type != "all") {
    # Construct SQL query for sample filtering
    sample_query <- "SELECT SampleID FROM sample_anno WHERE 1=1"

    if (data_type != "all") {
      sample_query <- paste0(sample_query, " AND DataType = '", data_type, "'")
    }

    if (tumor_type != "all") {
      sample_query <- paste0(sample_query, " AND TumorType = '", tumor_type, "'")
    }

    # Execute the query
    filtered_samples <- DBI::dbGetQuery(connection, sample_query)$SampleID

    if (length(filtered_samples) == 0) {
      stop("No samples match the specified data_type and tumor_type criteria")
    }
  }

  # Retrieve data for each table
  result_list <- list()

  for (table in feature_tables) {
    # Extract data source name from table name
    data_source <- sub(paste0("_", select_feas_type, "$"), "", table)

    # Query for the specified feature
    if (select_feas_type %in% c("mRNA", "cnv", "meth", "proteinrppa", "proteinms", "drug", "drug_raw")) {
      # For continuous data, get the row for the feature
      query <- paste0("SELECT * FROM ", table, " WHERE feature_id = '", select_feas, "'")
      feature_data <- DBI::dbGetQuery(connection, query)

      if (nrow(feature_data) == 0) {
        next  # Skip if feature not found
      }

      # Convert to vector format (excluding feature_id column)
      feature_vector <- as.numeric(as.vector(feature_data[1, -which(names(feature_data) == "feature_id")]))
      names(feature_vector) <- colnames(feature_data)[-which(names(feature_data) == "feature_id")]
    } else {
      # For discrete data like mutations, get sample IDs where feature is present
      query <- paste0("SELECT cells FROM ", table, " WHERE gene = '", select_feas, "'")
      feature_data <- DBI::dbGetQuery(connection, query)

      if (nrow(feature_data) == 0) {
        next  # Skip if feature not found
      }

      feature_vector <- feature_data$cells
    }

    # Filter by samples if needed
    if (!is.null(filtered_samples)) {
      if (select_feas_type %in% c("mRNA", "cnv", "meth", "proteinrppa", "proteinms", "drug", "drug_raw")) {
        common_samples <- intersect(names(feature_vector), filtered_samples)
        if (length(common_samples) == 0) {
          next  # Skip if no samples match the filter
        }
        feature_vector <- feature_vector[common_samples]
      } else {
        feature_vector <- intersect(feature_vector, filtered_samples)
        if (length(feature_vector) == 0) {
          next  # Skip if no samples match the filter
        }
      }
    }

    # Add to result list
    result_list[[data_source]] <- feature_vector
  }

  if (length(result_list) == 0) {
    stop("No data found for feature '", select_feas, "' with the specified criteria")
  }

  return(result_list)
}

#' Close DROMA Database Connection
#'
#' @description Closes the connection to the DROMA database
#' @param connection Optional database connection object. If NULL, uses global connection.
#' @return TRUE if successfully disconnected
#' @export
closeDROMADatabase <- function(connection = NULL) {
  if (is.null(connection)) {
    if (!exists("droma_db_connection", envir = .GlobalEnv)) {
      message("No open database connection found")
      return(invisible(FALSE))
    }
    connection <- get("droma_db_connection", envir = .GlobalEnv)
  }

  DBI::dbDisconnect(connection)

  if (exists("droma_db_connection", envir = .GlobalEnv)) {
    rm("droma_db_connection", envir = .GlobalEnv)
  }

  message("Database connection closed")
  invisible(TRUE)
}

#' List Available Tables in DROMA Database
#'
#' @description Provides information about tables available in the DROMA database
#' @param pattern Optional regex pattern to filter table names
#' @param connection Optional database connection object. If NULL, uses global connection
#' @return A data frame with table information
#' @export
listDROMADatabaseTables <- function(pattern = NULL, connection = NULL) {
  if (is.null(connection)) {
    if (!exists("droma_db_connection", envir = .GlobalEnv)) {
      stop("No database connection found. Connect first with connectDROMADatabase()")
    }
    connection <- get("droma_db_connection", envir = .GlobalEnv)
  }

  # Get table list
  tables <- DBI::dbListTables(connection)

  # Filter by pattern if provided
  if (!is.null(pattern)) {
    tables <- grep(pattern, tables, value = TRUE)
  }

  # Get metadata for each table
  if ("droma_metadata" %in% DBI::dbListTables(connection)) {
    metadata <- DBI::dbReadTable(connection, "droma_metadata")
    result <- metadata[metadata$table_name %in% tables, ]
  } else {
    # If metadata table doesn't exist, create basic info
    result <- data.frame(
      table_name = tables,
      row_count = sapply(tables, function(t)
        DBI::dbGetQuery(connection, paste0("SELECT COUNT(*) FROM ", t))[1,1]),
      stringsAsFactors = FALSE
    )
  }

  # Add categorization by data type
  result$data_type <- sub("_.*$", "", result$table_name)
  result$feature_type <- sub("^.*_", "", result$table_name)

  return(result)
}

#' List Available Projects in DROMA Database
#'
#' @description Lists all projects available in the DROMA database
#' @param connection Optional database connection object. If NULL, uses global connection
#' @param show_names_only Logical, if TRUE returns only a character vector of project names
#' @param project_data_types Character, project name to get specific data types for
#' @return A data frame with project information or a character vector of project names or data types
#' @export
listDROMAProjects <- function(connection = NULL, show_names_only = FALSE, project_data_types = NULL) {
  if (is.null(connection)) {
    if (!exists("droma_db_connection", envir = .GlobalEnv)) {
      stop("No database connection found. Connect first with connectDROMADatabase()")
    }
    connection <- get("droma_db_connection", envir = .GlobalEnv)
  }

  # Check if projects table exists
  if ("projects" %in% DBI::dbListTables(connection)) {
    projects_df <- DBI::dbReadTable(connection, "projects")

    # If user just wants project names, return them
    if (show_names_only) {
      return(projects_df$project_name)
    }

    # If user wants data types for a specific project
    if (!is.null(project_data_types)) {
      if (project_data_types %in% projects_df$project_name) {
        project_row <- projects_df[projects_df$project_name == project_data_types, ]
        # Split the data_types string by comma and return as a vector
        return(unlist(strsplit(project_row$data_types, ",")))
      } else {
        warning("Project '", project_data_types, "' not found")
        return(character(0))
      }
    }

    return(projects_df)
  }

  # Otherwise, try to infer projects from table names
  tables <- DBI::dbListTables(connection)

  # Extract project names from table prefixes
  project_names <- unique(sapply(tables, function(t) {
    parts <- strsplit(t, "_")[[1]]
    if (length(parts) >= 2 && !t %in% c("sample_anno", "drug_anno", "droma_metadata", "search_vectors")) {
      return(parts[1])
    } else {
      return(NA)
    }
  }))
  project_names <- project_names[!is.na(project_names)]

  if (length(project_names) == 0) {
    message("No projects found in database")
    if (show_names_only) {
      return(character(0))
    }
    return(data.frame())
  }

  # Return just project names if requested
  if (show_names_only) {
    return(project_names)
  }

  # If user wants data types for a specific project
  if (!is.null(project_data_types)) {
    if (project_data_types %in% project_names) {
      # Get all tables for this project
      project_tables <- grep(paste0("^", project_data_types, "_"), tables, value = TRUE)
      # Extract data types from table names
      data_types <- unique(sapply(project_tables, function(t) {
        sub(paste0("^", project_data_types, "_"), "", t)
      }))
      return(data_types)
    } else {
      warning("Project '", project_data_types, "' not found")
      return(character(0))
    }
  }

  # Create a data frame with project information
  result <- data.frame(
    project_name = project_names,
    stringsAsFactors = FALSE
  )

  return(result)
}

#' List Available Features in DROMA Database
#'
#' @description Lists all available features (genes, drugs, etc.) for a specific project and data type
#' @param project_name Character, the name of the project (e.g., "gCSI", "CCLE")
#' @param data_type Character, the type of data to query (e.g., "mRNA", "cnv", "drug", "mutation_gene")
#' @param connection Optional database connection object. If NULL, uses global connection
#' @param limit Integer, maximum number of features to return (default: NULL for all features)
#' @param pattern Character, optional regex pattern to filter feature names
#' @return A character vector of available feature names
#' @export
#' @examples
#' \dontrun{
#' # Connect to database
#' con <- connectDROMADatabase("path/to/droma.sqlite")
#'
#' # List all genes available in gCSI mRNA data
#' genes <- listDROMAFeatures("gCSI", "mRNA")
#'
#' # List all drugs available in gCSI drug response data
#' drugs <- listDROMAFeatures("gCSI", "drug")
#'
#' # List genes matching a pattern
#' brca_genes <- listDROMAFeatures("gCSI", "mRNA", pattern = "^BRCA")
#'
#' # List first 100 features
#' top_genes <- listDROMAFeatures("gCSI", "mRNA", limit = 100)
#' }
listDROMAFeatures <- function(project_name, data_type, connection = NULL, limit = NULL, pattern = NULL) {
  if (!requireNamespace("DBI", quietly = TRUE)) {
    stop("Package 'DBI' is required. Please install with install.packages('DBI')")
  }

  # Get connection from global environment if not provided
  if (is.null(connection)) {
    if (!exists("droma_db_connection", envir = .GlobalEnv)) {
      stop("No database connection found. Connect first with connectDROMADatabase()")
    }
    connection <- get("droma_db_connection", envir = .GlobalEnv)
  }

  # Construct table name
  table_name <- paste0(project_name, "_", data_type)

  # Check if table exists
  all_tables <- DBI::dbListTables(connection)
  if (!table_name %in% all_tables) {
    stop("Table '", table_name, "' not found. Available tables: ",
         paste(grep(paste0("^", project_name, "_"), all_tables, value = TRUE), collapse = ", "))
  }

  # Determine the column name based on data type
  if (data_type %in% c("mRNA", "cnv", "meth", "proteinrppa", "proteinms", "drug", "drug_raw")) {
    # For continuous data, features are in feature_id column
    feature_column <- "feature_id"
  } else if (data_type %in% c("mutation_gene", "mutation_site", "fusion")) {
    # For discrete data, features are in genes column
    feature_column <- "genes"
  } else {
    # Try to detect the column automatically
    # Get column names from the table
    columns_query <- paste0("PRAGMA table_info(", table_name, ")")
    columns_info <- DBI::dbGetQuery(connection, columns_query)

    if ("feature_id" %in% columns_info$name) {
      feature_column <- "feature_id"
    } else if ("genes" %in% columns_info$name) {
      feature_column <- "genes"
    } else {
      stop("Cannot determine feature column for data type '", data_type,
           "'. Available columns: ", paste(columns_info$name, collapse = ", "))
    }
  }

  # Construct query to get distinct features
  query <- paste0("SELECT DISTINCT ", feature_column, " FROM ", table_name,
                  " WHERE ", feature_column, " IS NOT NULL")

  # Add pattern filter if specified
  if (!is.null(pattern)) {
    # Convert regex pattern to SQL LIKE pattern for basic matching
    # For simple patterns like "^BRCA", convert to "BRCA%"
    # For patterns with *, convert to %
    like_pattern <- pattern

    # Handle common regex patterns
    if (grepl("^\\^", pattern)) {
      # Pattern starts with ^, remove ^ and add % at end
      like_pattern <- paste0(sub("^\\^", "", pattern), "%")
    } else if (grepl("\\$$", pattern)) {
      # Pattern ends with $, remove $ and add % at start
      like_pattern <- paste0("%", sub("\\$$", "", pattern))
    } else if (grepl("^\\^.*\\$$", pattern)) {
      # Pattern has both ^ and $, remove both (exact match)
      like_pattern <- gsub("^\\^|\\$$", "", pattern)
    } else {
      # Default: add % on both sides for contains matching
      like_pattern <- paste0("%", pattern, "%")
    }

    # Replace common regex characters with SQL LIKE equivalents
    like_pattern <- gsub("\\*", "%", like_pattern)
    like_pattern <- gsub("\\.", "_", like_pattern)

    query <- paste0(query, " AND ", feature_column, " LIKE '", like_pattern, "'")
  }

  # Add ordering
  query <- paste0(query, " ORDER BY ", feature_column)

  # Add limit if specified
  if (!is.null(limit) && is.numeric(limit) && limit > 0) {
    query <- paste0(query, " LIMIT ", as.integer(limit))
  }

  # Execute query
  tryCatch({
    result <- DBI::dbGetQuery(connection, query)
    features <- result[[feature_column]]

    if (length(features) == 0) {
      if (!is.null(pattern)) {
        message("No features found matching pattern '", pattern, "' in ", table_name)
      } else {
        message("No features found in ", table_name)
      }
      return(character(0))
    }

    # Print summary information
    total_query <- paste0("SELECT COUNT(DISTINCT ", feature_column, ") as total FROM ", table_name,
                         " WHERE ", feature_column, " IS NOT NULL")
    total_result <- DBI::dbGetQuery(connection, total_query)
    total_features <- total_result$total

    if (!is.null(pattern)) {
      message("Found ", length(features), " features matching pattern '", pattern,
              "' out of ", total_features, " total features in ", table_name)
    } else if (!is.null(limit)) {
      message("Showing first ", length(features), " features out of ", total_features,
              " total features in ", table_name)
    } else {
      message("Found ", length(features), " features in ", table_name)
    }

    return(features)

  }, error = function(e) {
    stop("Error querying features from ", table_name, ": ", e$message)
  })
}

#' List Available Samples in DROMA Database
#'
#' @description Lists all available samples for a specific project, optionally filtered by data type or tumor type
#' @param project_name Character, the name of the project (e.g., "gCSI", "CCLE")
#' @param data_type Character, filter by data type: "all" (default), "CellLine", "PDO", "PDC", or "PDX"
#' @param tumor_type Character, filter by tumor type: "all" (default) or specific tumor type
#' @param connection Optional database connection object. If NULL, uses global connection
#' @param limit Integer, maximum number of samples to return (default: NULL for all samples)
#' @return A character vector of available sample IDs
#' @export
#' @examples
#' \dontrun{
#' # Connect to database
#' con <- connectDROMADatabase("path/to/droma.sqlite")
#'
#' # List all samples for gCSI project
#' samples <- listDROMASamples("gCSI")
#'
#' # List only cell line samples
#' cell_lines <- listDROMASamples("gCSI", data_type = "CellLine")
#'
#' # List only breast cancer samples
#' breast_samples <- listDROMASamples("gCSI", tumor_type = "breast cancer")
#'
#' # List first 50 samples
#' top_samples <- listDROMASamples("gCSI", limit = 50)
#' }
listDROMASamples <- function(project_name, data_type = "all", tumor_type = "all",
                            connection = NULL, limit = NULL) {
  if (!requireNamespace("DBI", quietly = TRUE)) {
    stop("Package 'DBI' is required. Please install with install.packages('DBI')")
  }

  # Get connection from global environment if not provided
  if (is.null(connection)) {
    if (!exists("droma_db_connection", envir = .GlobalEnv)) {
      stop("No database connection found. Connect first with connectDROMADatabase()")
    }
    connection <- get("droma_db_connection", envir = .GlobalEnv)
  }

  # Check if sample_anno table exists
  all_tables <- DBI::dbListTables(connection)
  if (!"sample_anno" %in% all_tables) {
    stop("Sample annotation table 'sample_anno' not found in database")
  }

  # Construct query
  query <- "SELECT DISTINCT SampleID FROM sample_anno WHERE ProjectID = ?"
  params <- list(project_name)

  # Add data type filter
  if (data_type != "all") {
    query <- paste0(query, " AND DataType = ?")
    params <- append(params, data_type)
  }

  # Add tumor type filter
  if (tumor_type != "all") {
    query <- paste0(query, " AND TumorType = ?")
    params <- append(params, tumor_type)
  }

  # Add ordering
  query <- paste0(query, " ORDER BY SampleID")

  # Add limit if specified
  if (!is.null(limit) && is.numeric(limit) && limit > 0) {
    query <- paste0(query, " LIMIT ", as.integer(limit))
  }

  # Execute query
  tryCatch({
    result <- DBI::dbGetQuery(connection, query, params = params)
    samples <- result$SampleID

    if (length(samples) == 0) {
      message("No samples found for project '", project_name, "'",
              if(data_type != "all") paste0(" with data_type '", data_type, "'") else "",
              if(tumor_type != "all") paste0(" with tumor_type '", tumor_type, "'") else "")
      return(character(0))
    }

    # Print summary information
    total_query <- "SELECT COUNT(DISTINCT SampleID) as total FROM sample_anno WHERE ProjectID = ?"
    total_result <- DBI::dbGetQuery(connection, total_query, params = list(project_name))
    total_samples <- total_result$total

    filter_desc <- ""
    if (data_type != "all" || tumor_type != "all") {
      filters <- c()
      if (data_type != "all") filters <- c(filters, paste0("data_type='", data_type, "'"))
      if (tumor_type != "all") filters <- c(filters, paste0("tumor_type='", tumor_type, "'"))
      filter_desc <- paste0(" (filtered by ", paste(filters, collapse = " and "), ")")
    }

    if (!is.null(limit)) {
      message("Showing first ", length(samples), " samples out of ", total_samples,
              " total samples for project '", project_name, "'", filter_desc)
    } else {
      message("Found ", length(samples), " samples for project '", project_name, "'", filter_desc)
    }

    return(samples)

  }, error = function(e) {
    stop("Error querying samples for project '", project_name, "': ", e$message)
  })
}

#' Get Annotation Data from DROMA Database
#'
#' @description Retrieves annotation data from either sample_anno or drug_anno tables
#' @param anno_type Character, type of annotation to retrieve: "sample" or "drug"
#' @param project_name Character, optional project name to filter results (default: NULL for all projects)
#' @param ids Character vector, optional specific IDs to retrieve (SampleID for samples, DrugName for drugs)
#' @param data_type Character, for sample annotations only: filter by data type ("all", "CellLine", "PDO", "PDC", "PDX")
#' @param tumor_type Character, for sample annotations only: filter by tumor type ("all" or specific type)
#' @param connection Optional database connection object. If NULL, uses global connection
#' @param limit Integer, maximum number of records to return (default: NULL for all records)
#' @return A data frame containing the annotation data
#' @export
#' @examples
#' \dontrun{
#' # Connect to database
#' con <- connectDROMADatabase("path/to/droma.sqlite")
#'
#' # Get all sample annotations
#' sample_anno <- getDROMAAnnotation("sample")
#'
#' # Get sample annotations for gCSI project only
#' gCSI_samples <- getDROMAAnnotation("sample", project_name = "gCSI")
#'
#' # Get sample annotations for specific samples
#' specific_samples <- getDROMAAnnotation("sample", ids = c("22RV1", "2313287"))
#'
#' # Get cell line samples only
#' cell_lines <- getDROMAAnnotation("sample", data_type = "CellLine")
#'
#' # Get breast cancer samples only
#' breast_samples <- getDROMAAnnotation("sample", tumor_type = "breast cancer")
#'
#' # Get all drug annotations
#' drug_anno <- getDROMAAnnotation("drug")
#'
#' # Get drug annotations for gCSI project only
#' gCSI_drugs <- getDROMAAnnotation("drug", project_name = "gCSI")
#'
#' # Get annotations for specific drugs
#' specific_drugs <- getDROMAAnnotation("drug", ids = c("Tamoxifen", "Cisplatin"))
#' }
getDROMAAnnotation <- function(anno_type, project_name = NULL, ids = NULL,
                              data_type = "all", tumor_type = "all",
                              connection = NULL, limit = NULL) {
  if (!requireNamespace("DBI", quietly = TRUE)) {
    stop("Package 'DBI' is required. Please install with install.packages('DBI')")
  }

  # Validate anno_type
  if (!anno_type %in% c("sample", "drug")) {
    stop("anno_type must be either 'sample' or 'drug'")
  }

  # Get connection from global environment if not provided
  if (is.null(connection)) {
    if (!exists("droma_db_connection", envir = .GlobalEnv)) {
      stop("No database connection found. Connect first with connectDROMADatabase()")
    }
    connection <- get("droma_db_connection", envir = .GlobalEnv)
  }

  # Determine table name and ID column
  if (anno_type == "sample") {
    table_name <- "sample_anno"
    id_column <- "SampleID"
    project_column <- "ProjectID"
  } else {
    table_name <- "drug_anno"
    id_column <- "DrugName"
    project_column <- "ProjectID"
  }

  # Check if table exists
  all_tables <- DBI::dbListTables(connection)
  if (!table_name %in% all_tables) {
    stop("Annotation table '", table_name, "' not found in database")
  }

  # Build query
  query <- paste0("SELECT * FROM ", table_name, " WHERE 1=1")
  params <- list()

  # Add project filter
  if (!is.null(project_name)) {
    query <- paste0(query, " AND ", project_column, " = ?")
    params <- append(params, project_name)
  }

  # Add ID filter
  if (!is.null(ids) && length(ids) > 0) {
    placeholders <- paste(rep("?", length(ids)), collapse = ",")
    query <- paste0(query, " AND ", id_column, " IN (", placeholders, ")")
    params <- append(params, as.list(ids))
  }

  # Add sample-specific filters
  if (anno_type == "sample") {
    # Add data type filter
    if (data_type != "all") {
      query <- paste0(query, " AND DataType = ?")
      params <- append(params, data_type)
    }

    # Add tumor type filter
    if (tumor_type != "all") {
      query <- paste0(query, " AND TumorType = ?")
      params <- append(params, tumor_type)
    }
  }

  # Add ordering
  query <- paste0(query, " ORDER BY ", id_column)

  # Add limit if specified
  if (!is.null(limit) && is.numeric(limit) && limit > 0) {
    query <- paste0(query, " LIMIT ", as.integer(limit))
  }

  # Execute query
  tryCatch({
    if (length(params) > 0) {
      result <- DBI::dbGetQuery(connection, query, params = params)
    } else {
      result <- DBI::dbGetQuery(connection, query)
    }

    if (nrow(result) == 0) {
      filter_desc <- ""
      filters <- c()

      if (!is.null(project_name)) {
        filters <- c(filters, paste0("project='", project_name, "'"))
      }
      if (!is.null(ids)) {
        filters <- c(filters, paste0("specific IDs (", length(ids), " requested)"))
      }
      if (anno_type == "sample") {
        if (data_type != "all") {
          filters <- c(filters, paste0("data_type='", data_type, "'"))
        }
        if (tumor_type != "all") {
          filters <- c(filters, paste0("tumor_type='", tumor_type, "'"))
        }
      }

      if (length(filters) > 0) {
        filter_desc <- paste0(" with filters: ", paste(filters, collapse = ", "))
      }

      message("No ", anno_type, " annotations found", filter_desc)
      return(data.frame())
    }

    # Print summary information
    total_query <- paste0("SELECT COUNT(*) as total FROM ", table_name)
    total_result <- DBI::dbGetQuery(connection, total_query)
    total_records <- total_result$total

    filter_desc <- ""
    if (!is.null(project_name) || !is.null(ids) ||
        (anno_type == "sample" && (data_type != "all" || tumor_type != "all"))) {
      filters <- c()

      if (!is.null(project_name)) {
        filters <- c(filters, paste0("project='", project_name, "'"))
      }
      if (!is.null(ids)) {
        filters <- c(filters, paste0("specific IDs"))
      }
      if (anno_type == "sample") {
        if (data_type != "all") {
          filters <- c(filters, paste0("data_type='", data_type, "'"))
        }
        if (tumor_type != "all") {
          filters <- c(filters, paste0("tumor_type='", tumor_type, "'"))
        }
      }

      filter_desc <- paste0(" (filtered by ", paste(filters, collapse = " and "), ")")
    }

    if (!is.null(limit)) {
      message("Retrieved first ", nrow(result), " ", anno_type, " annotations out of ",
              total_records, " total records", filter_desc)
    } else {
      message("Retrieved ", nrow(result), " ", anno_type, " annotations", filter_desc)
    }

    return(result)

  }, error = function(e) {
    stop("Error querying ", anno_type, " annotations: ", e$message)
  })
}




================================================
FILE: R/DromaSet-class.R
================================================
#!/usr/bin/env Rscript

#' DromaSet Class
#'
#' @description A class to represent a DROMA project dataset with drug response and omics data.
#' Each DromaSet contains treatment response data (drug sensitivity) and multiple molecular profiles
#' (omics data) for a specific project.
#'
#' @slot name Character string, the name of the dataset (e.g., "gCSI", "CCLE")
#' @slot treatmentResponse List containing drug response data matrices
#' @slot molecularProfiles List containing different types of molecular data (omics)
#' @slot sampleMetadata Data frame with sample annotations
#' @slot treatmentMetadata Data frame with drug annotations
#' @slot datasetType Character string, the type of dataset (e.g., "CellLine", "PDX", "PDO")
#' @slot db_info List containing database connection information
#' @export
setClass("DromaSet",
  slots = c(
    name = "character",
    treatmentResponse = "list",
    molecularProfiles = "list",
    sampleMetadata = "data.frame",
    treatmentMetadata = "data.frame",
    datasetType = "character",
    db_info = "list"
  ),
  prototype = list(
    name = NA_character_,
    treatmentResponse = list(),
    molecularProfiles = list(),
    sampleMetadata = data.frame(),
    treatmentMetadata = data.frame(),
    datasetType = NA_character_,
    db_info = list()
  )
)

#' Create a DromaSet Object
#'
#' @description Creates a DromaSet object to store drug response and omics data for a specific project
#' @param name Character string, the name of the dataset (e.g., "gCSI", "CCLE")
#' @param treatmentResponse List containing drug response data matrices
#' @param molecularProfiles List containing different types of molecular data (omics)
#' @param sampleMetadata Data frame with sample annotations
#' @param treatmentMetadata Data frame with drug annotations
#' @param datasetType Character string, the type of dataset (e.g., "CellLine", "PDX", "PDO")
#' @param db_info List containing database connection information
#' @return A DromaSet object
#' @export
#' @examples
#' \dontrun{
#' # Create a DromaSet object for gCSI data
#' gCSI <- DromaSet(name = "gCSI",
#'                  datasetType = "CellLine",
#'                  db_info = list(db_path = "~/droma.sqlite", db_group = "gCSI"))
#' }
DromaSet <- function(name,
                   treatmentResponse = list(),
                   molecularProfiles = list(),
                   sampleMetadata = data.frame(),
                   treatmentMetadata = data.frame(),
                   datasetType = NA_character_,
                   db_info = list()) {

  # Create new DromaSet object
  object <- new("DromaSet",
              name = name,
              treatmentResponse = treatmentResponse,
              molecularProfiles = molecularProfiles,
              sampleMetadata = sampleMetadata,
              treatmentMetadata = treatmentMetadata,
              datasetType = datasetType,
              db_info = db_info)

  # Return the object
  return(object)
}

#' Show Method for DromaSet objects
#'
#' @description Displays information about a DromaSet object
#' @param object A DromaSet object
#' @return NULL, prints information to console
#' @export
setMethod("show", "DromaSet", function(object) {
  cat("DromaSet Object:", object@name, "\n")
  cat("Dataset Type:", object@datasetType, "\n\n")

  # Treatment Response
  cat("Treatment Response Data:\n")
  if (length(object@treatmentResponse) > 0) {
    tr_info <- lapply(object@treatmentResponse, function(x) {
      if(is.matrix(x) || is.data.frame(x)) {
        paste0("  (", nrow(x), " drugs x ", ncol(x), " samples)")
      } else {
        "  (data in database)"
      }
    })
    cat(paste(names(object@treatmentResponse), tr_info, sep = ": ", collapse = "\n"), "\n")
  } else {
    cat("  None loaded (may be available in database)\n")
  }

  # Molecular Profiles
  cat("\nMolecular Profiles:\n")
  if (length(object@molecularProfiles) > 0) {
    mp_info <- lapply(object@molecularProfiles, function(x) {
      if(is.matrix(x) || is.data.frame(x)) {
        paste0("  (", nrow(x), " features x ", ncol(x), " samples)")
      } else {
        "  (data in database)"
      }
    })
    cat(paste(names(object@molecularProfiles), mp_info, sep = ": ", collapse = "\n"), "\n")
  } else {
    cat("  None loaded (may be available in database)\n")
  }

  # Database information
  cat("\nDatabase Connection Information:\n")
  if (length(object@db_info) > 0) {
    cat("  Path:", ifelse(is.null(object@db_info$db_path), "Not specified", object@db_info$db_path), "\n")
    cat("  Group:", ifelse(is.null(object@db_info$db_group), object@name, object@db_info$db_group), "\n")
  } else {
    cat("  No database information available\n")
  }

  invisible(NULL)
})

#' Get Available Molecular Profile Types
#'
#' @description Returns the types of molecular profiles available for a DromaSet
#' @param object A DromaSet object
#' @param include_db Logical, whether to include profiles available in the database but not loaded (default: TRUE)
#' @return Character vector of available molecular profile types
#' @export
setGeneric("availableMolecularProfiles", function(object, include_db = TRUE) standardGeneric("availableMolecularProfiles"))

#' @rdname availableMolecularProfiles
#' @export
setMethod("availableMolecularProfiles", "DromaSet", function(object, include_db = TRUE) {
  # Get profiles already loaded in the object
  loaded_profiles <- names(object@molecularProfiles)

  # If requested, check database for additional profiles
  if (include_db && length(object@db_info) > 0 && !is.null(object@db_info$db_path)) {
    if (file.exists(object@db_info$db_path)) {
      # Connect to database
      con <- DBI::dbConnect(RSQLite::SQLite(), object@db_info$db_path)
      on.exit(DBI::dbDisconnect(con), add = TRUE)

      # Get group prefix (if specified) or use dataset name
      group_prefix <- ifelse(is.null(object@db_info$db_group), object@name, object@db_info$db_group)

      # List all tables with this prefix
      all_tables <- DBI::dbListTables(con)
      project_tables <- grep(paste0("^", group_prefix, "_"), all_tables, value = TRUE)

      # Extract molecular profile types from table names
      if (length(project_tables) > 0) {
        # Remove prefix to get profile types
        db_profiles <- unique(sub(paste0("^", group_prefix, "_"), "", project_tables))
        # Remove 'drug' and 'drug_raw' which are treatment responses
        db_profiles <- db_profiles[!db_profiles %in% c("drug", "drug_raw")]

        # Combine with loaded profiles
        return(unique(c(loaded_profiles, db_profiles)))
      }
    }
  }

  return(loaded_profiles)
})

#' Get Available Treatment Response Types
#'
#' @description Returns the types of treatment response data available for a DromaSet
#' @param object A DromaSet object
#' @param include_db Logical, whether to include data available in the database but not loaded (default: TRUE)
#' @return Character vector of available treatment response types
#' @export
setGeneric("availableTreatmentResponses", function(object, include_db = TRUE) standardGeneric("availableTreatmentResponses"))

#' @rdname availableTreatmentResponses
#' @export
setMethod("availableTreatmentResponses", "DromaSet", function(object, include_db = TRUE) {
  # Get responses already loaded in the object
  loaded_responses <- names(object@treatmentResponse)

  # If requested, check database for additional responses
  if (include_db && length(object@db_info) > 0 && !is.null(object@db_info$db_path)) {
    if (file.exists(object@db_info$db_path)) {
      # Connect to database
      con <- DBI::dbConnect(RSQLite::SQLite(), object@db_info$db_path)
      on.exit(DBI::dbDisconnect(con), add = TRUE)

      # Get group prefix (if specified) or use dataset name
      group_prefix <- ifelse(is.null(object@db_info$db_group), object@name, object@db_info$db_group)

      # Look for drug and drug_raw tables
      all_tables <- DBI::dbListTables(con)
      drug_tables <- grep(paste0("^", group_prefix, "_(drug|drug_raw)$"), all_tables, value = TRUE)

      # Extract response types from table names
      if (length(drug_tables) > 0) {
        # Remove prefix to get response types
        db_responses <- unique(sub(paste0("^", group_prefix, "_"), "", drug_tables))

        # Combine with loaded responses
        return(unique(c(loaded_responses, db_responses)))
      }
    }
  }

  return(loaded_responses)
})

#' Load Molecular Profiles from Database
#'
#' @description Loads specific molecular profile data from the database into a DromaSet object
#' @param object A DromaSet object
#' @param molecular_type The type of molecular data to load (e.g., "mRNA", "cnv", "mutation_gene") or "all" to load all available types
#' @param features Optional vector of feature names to load. If NULL, loads all features.
#' @param samples Optional vector of sample IDs to load. If NULL, loads all samples.
#' @param return_data Logical, if TRUE returns the loaded data directly instead of updating the object (default: FALSE)
#' @param data_type Filter by data type: "all" (default), "CellLine", "PDO" (patient-derived organoids), "PDC", or "PDX"
#' @param tumor_type Filter by tumor type: "all" (default) or any specific tumor type (e.g., "lung cancer", "breast cancer")
#' @return Updated DromaSet object with loaded molecular data or the loaded data directly if return_data=TRUE
#' @export
setGeneric("loadMolecularProfiles", function(object, molecular_type, features = NULL, samples = NULL, return_data = FALSE, data_type = "all", tumor_type = "all")
  standardGeneric("loadMolecularProfiles"))

#' @rdname loadMolecularProfiles
#' @export
setMethod("loadMolecularProfiles", "DromaSet", function(object, molecular_type, features = NULL, samples = NULL, return_data = FALSE, data_type = "all", tumor_type = "all") {
  # Handle "all" molecular_type option
  if (molecular_type == "all") {
    # Get all available molecular profile types
    available_types <- availableMolecularProfiles(object, include_db = TRUE)

    if (length(available_types) == 0) {
      warning("No molecular profile types available for dataset '", object@name, "'")
      if (return_data) {
        return(list())
      } else {
        return(object)
      }
    }

    # Load each molecular profile type
    all_data <- list()

    for (mol_type in available_types) {
      tryCatch({
        # Load individual molecular profile
        mol_data <- loadMolecularProfiles(
          object = object,
          molecular_type = mol_type,
          features = features,
          samples = samples,
          return_data = TRUE,
          data_type = data_type,
          tumor_type = tumor_type
        )

        # Store the data
        all_data[[mol_type]] <- mol_data

        # Update object if not returning data
        if (!return_data) {
          object@molecularProfiles[[mol_type]] <- mol_data
        }

        message("Loaded molecular profile: ", mol_type, " (",
               ifelse(is.matrix(mol_data) || is.data.frame(mol_data),
                     paste(nrow(mol_data), "features x", ncol(mol_data), "samples"),
                     "data loaded"), ")")

      }, error = function(e) {
        warning("Failed to load molecular profile '", mol_type, "': ", e$message)
      })
    }

    # Return results
    if (return_data) {
      return(all_data)
    } else {
      message("Loaded ", length(all_data), " molecular profile types for dataset '", object@name, "'")
      return(object)
    }
  }

  # Original single molecular_type loading logic
  # Verify we have database connection info
  if (length(object@db_info) == 0 || is.null(object@db_info$db_path)) {
    stop("No database connection information available")
  }

  if (!file.exists(object@db_info$db_path)) {
    stop("Database file not found: ", object@db_info$db_path)
  }

  # Get group prefix (if specified) or use dataset name
  group_prefix <- ifelse(is.null(object@db_info$db_group), object@name, object@db_info$db_group)

  # Connect to database
  con <- DBI::dbConnect(RSQLite::SQLite(), object@db_info$db_path)
  on.exit(DBI::dbDisconnect(con), add = TRUE)

  # Check if the table exists
  table_name <- paste0(group_prefix, "_", molecular_type)
  all_tables <- DBI::dbListTables(con)

  if (!table_name %in% all_tables) {
    stop("Molecular profile type '", molecular_type, "' not found for dataset '", object@name, "'")
  }

  # Filter samples by data_type and tumor_type if specified
  if (data_type != "all" || tumor_type != "all") {
    if (nrow(object@sampleMetadata) == 0) {
      warning("Sample metadata not available for filtering by data_type or tumor_type")
    } else {
      filtered_samples <- object@sampleMetadata$SampleID

      if (data_type != "all") {
        filtered_samples <- object@sampleMetadata$SampleID[object@sampleMetadata$DataType == data_type]
        if (length(filtered_samples) == 0) {
          warning("No samples match the specified data_type: ", data_type)
          if (return_data) {
            return(if(molecular_type %in% c("mutation_gene", "mutation_site", "fusion")) data.frame() else matrix(nrow = 0, ncol = 0))
          } else {
            if (molecular_type %in% c("mutation_gene", "mutation_site", "fusion")) {
              object@molecularProfiles[[molecular_type]] <- data.frame()
            } else {
              object@molecularProfiles[[molecular_type]] <- matrix(nrow = 0, ncol = 0)
            }
            return(object)
          }
        }
      }

      if (tumor_type != "all") {
        tumor_samples <- object@sampleMetadata$SampleID[object@sampleMetadata$TumorType == tumor_type]
        if (length(tumor_samples) == 0) {
          warning("No samples match the specified tumor_type: ", tumor_type)
          if (return_data) {
            return(if(molecular_type %in% c("mutation_gene", "mutation_site", "fusion")) data.frame() else matrix(nrow = 0, ncol = 0))
          } else {
            if (molecular_type %in% c("mutation_gene", "mutation_site", "fusion")) {
              object@molecularProfiles[[molecular_type]] <- data.frame()
            } else {
              object@molecularProfiles[[molecular_type]] <- matrix(nrow = 0, ncol = 0)
            }
            return(object)
          }
        }
        filtered_samples <- intersect(filtered_samples, tumor_samples)
      }

      # Update samples parameter with filtered samples
      if (is.null(samples)) {
        samples <- filtered_samples
      } else {
        samples <- intersect(samples, filtered_samples)
        if (length(samples) == 0) {
          warning("No samples match both the specified filters and sample list")
          if (return_data) {
            return(if(molecular_type %in% c("mutation_gene", "mutation_site", "fusion")) data.frame() else matrix(nrow = 0, ncol = 0))
          } else {
            if (molecular_type %in% c("mutation_gene", "mutation_site", "fusion")) {
              object@molecularProfiles[[molecular_type]] <- data.frame()
            } else {
              object@molecularProfiles[[molecular_type]] <- matrix(nrow = 0, ncol = 0)
            }
            return(object)
          }
        }
      }
    }
  }

  # Variable to store the loaded data
  loaded_data <- NULL

  # Construct query based on features and samples
  if (molecular_type %in% c("mRNA", "cnv", "meth", "proteinrppa", "proteinms")) {
    # For continuous data matrices
    query <- paste0("SELECT * FROM ", table_name)

    # Add feature filter if specified
    if (!is.null(features)) {
      # First check if all features exist in the database
      features_check_query <- paste0("SELECT DISTINCT feature_id FROM ", table_name)
      all_features <- DBI::dbGetQuery(con, features_check_query)$feature_id

      missing_features <- setdiff(features, all_features)
      if (length(missing_features) > 0) {
        warning("The following features do not exist in the ", molecular_type, " data: ",
                paste(missing_features, collapse = ", "))
      }

      # Only query for features that exist
      existing_features <- intersect(features, all_features)
      if (length(existing_features) == 0) {
        warning("None of the specified features exist in the ", molecular_type, " data")
        if (return_data) {
          return(matrix(nrow = 0, ncol = 0))
        } else {
          object@molecularProfiles[[molecular_type]] <- matrix(nrow = 0, ncol = 0)
          return(object)
        }
      }

      features_str <- paste0("'", existing_features, "'", collapse = ",")
      query <- paste0(query, " WHERE feature_id IN (", features_str, ")")
    }

    # Execute query
    data <- DBI::dbGetQuery(con, query)

    # Reshape to matrix format
    if (nrow(data) > 0) {
      # Extract feature_id column
      feature_ids <- data$feature_id
      data$feature_id <- NULL

      # Convert to matrix
      mat <- as.matrix(data)
      rownames(mat) <- feature_ids

      # Filter by samples if needed
      if (!is.null(samples)) {
        # Check for missing samples
        missing_samples <- setdiff(samples, colnames(mat))
        if (length(missing_samples) > 0) {
          warning("The following samples do not exist in the ", molecular_type, " data: ",
                  paste(missing_samples, collapse = ", "))
        }

        common_samples <- intersect(colnames(mat), samples)
        if (length(common_samples) == 0) {
          warning("No samples match the specified filter")
          mat <- matrix(nrow = 0, ncol = 0)
        } else {
          mat <- mat[, common_samples, drop = FALSE]
        }
      }

      # Store the loaded data
      loaded_data <- mat

      # Store in object if not returning data directly
      if (!return_data) {
        object@molecularProfiles[[molecular_type]] <- mat
      }
    } else {
      warning("No data found for molecular profile type: ", molecular_type)
      loaded_data <- matrix(nrow = 0, ncol = 0)

      if (!return_data) {
        object@molecularProfiles[[molecular_type]] <- matrix(nrow = 0, ncol = 0)
      }
    }
  } else if (molecular_type %in% c("mutation_gene", "mutation_site", "fusion")) {
    # For discrete data (mutations, fusions)
    query <- paste0("SELECT * FROM ", table_name)

    # Add feature filter if specified
    if (!is.null(features)) {
      # First check if all features (genes) exist in the database
      genes_check_query <- paste0("SELECT DISTINCT genes FROM ", table_name)
      all_genes <- DBI::dbGetQuery(con, genes_check_query)$genes

      missing_genes <- setdiff(features, all_genes)
      if (length(missing_genes) > 0) {
        warning("The following genes do not exist in the ", molecular_type, " data: ",
                paste(missing_genes, collapse = ", "))
      }

      # Only query for genes that exist
      existing_genes <- intersect(features, all_genes)
      if (length(existing_genes) == 0) {
        warning("None of the specified genes exist in the ", molecular_type, " data")
        if (return_data) {
          return(data.frame())
        } else {
          object@molecularProfiles[[molecular_type]] <- data.frame()
          return(object)
        }
      }

      features_str <- paste0("'", existing_genes, "'", collapse = ",")
      query <- paste0(query, " WHERE genes IN (", features_str, ")")
    }

    # Execute query
    data <- DBI::dbGetQuery(con, query)

    # Filter by samples if needed
    if (!is.null(samples) && nrow(data) > 0) {
      # Check for missing samples
      if ("cells" %in% colnames(data)) {
        missing_samples <- setdiff(samples, unique(data$cells))
        if (length(missing_samples) > 0) {
          warning("The following samples do not exist in the ", molecular_type, " data: ",
                  paste(missing_samples, collapse = ", "))
        }

        data <- data[data$cells %in% samples, ]
      }
    }

    # Store the loaded data
    loaded_data <- data

    # Store in object if not returning data directly
    if (!return_data) {
      if (nrow(data) > 0) {
        object@molecularProfiles[[molecular_type]] <- data
      } else {
        warning("No data found for molecular profile type: ", molecular_type)
        object@molecularProfiles[[molecular_type]] <- data.frame()
      }
    } else if (nrow(data) == 0) {
      warning("No data found for molecular profile type: ", molecular_type)
      loaded_data <- data.frame()
    }
  } else {
    warning("Unrecognized molecular profile type: ", molecular_type)
    if (return_data) {
      return(NULL)
    }
  }

  # Return either the updated object or the loaded data
  if (return_data) {
    return(loaded_data)
  } else {
    return(object)
  }
})

#' Load Treatment Response from Database
#'
#' @description Loads drug response data from the database into a DromaSet object
#' @param object A DromaSet object
#' @param drugs Optional vector of drug names to load. If NULL, loads all drugs.
#' @param samples Optional vector of sample IDs to load. If NULL, loads all samples.
#' @param return_data Logical, if TRUE returns the loaded data directly instead of updating the object (default: FALSE)
#' @param data_type Filter by data type: "all" (default), "CellLine", "PDO" (patient-derived organoids), "PDC", or "PDX"
#' @param tumor_type Filter by tumor type: "all" (default) or any specific tumor type (e.g., "lung cancer", "breast cancer")
#' @return Updated DromaSet object with loaded drug response data or the loaded data directly if return_data=TRUE
#' @export
setGeneric("loadTreatmentResponse", function(object, drugs = NULL, samples = NULL, return_data = FALSE, data_type = "all", tumor_type = "all")
  standardGeneric("loadTreatmentResponse"))

#' @rdname loadTreatmentResponse
#' @export
setMethod("loadTreatmentResponse", "DromaSet", function(object, drugs = NULL, samples = NULL, return_data = FALSE, data_type = "all", tumor_type = "all") {
  # Verify we have database connection info
  if (length(object@db_info) == 0 || is.null(object@db_info$db_path)) {
    stop("No database connection information available")
  }

  if (!file.exists(object@db_info$db_path)) {
    stop("Database file not found: ", object@db_info$db_path)
  }

  # Get group prefix (if specified) or use dataset name
  group_prefix <- ifelse(is.null(object@db_info$db_group), object@name, object@db_info$db_group)

  # Connect to database
  con <- DBI::dbConnect(RSQLite::SQLite(), object@db_info$db_path)
  on.exit(DBI::dbDisconnect(con), add = TRUE)

  # Check if the drug table exists
  table_name <- paste0(group_prefix, "_drug")
  all_tables <- DBI::dbListTables(con)

  if (!table_name %in% all_tables) {
    stop("Treatment response data not found for dataset '", object@name, "'")
  }

  # Filter samples by data_type and tumor_type if specified
  if (data_type != "all" || tumor_type != "all") {
    if (nrow(object@sampleMetadata) == 0) {
      warning("Sample metadata not available for filtering by data_type or tumor_type")
    } else {
      filtered_samples <- object@sampleMetadata$SampleID

      if (data_type != "all") {
        filtered_samples <- object@sampleMetadata$SampleID[object@sampleMetadata$DataType == data_type]
        if (length(filtered_samples) == 0) {
          warning("No samples match the specified data_type: ", data_type)
          if (return_data) {
            return(matrix(nrow = 0, ncol = 0))
          } else {
            object@treatmentResponse[["drug"]] <- matrix(nrow = 0, ncol = 0)
            return(object)
          }
        }
      }

      if (tumor_type != "all") {
        tumor_samples <- object@sampleMetadata$SampleID[object@sampleMetadata$TumorType == tumor_type]
        if (length(tumor_samples) == 0) {
          warning("No samples match the specified tumor_type: ", tumor_type)
          if (return_data) {
            return(matrix(nrow = 0, ncol = 0))
          } else {
            object@treatmentResponse[["drug"]] <- matrix(nrow = 0, ncol = 0)
            return(object)
          }
        }
        filtered_samples <- intersect(filtered_samples, tumor_samples)
      }

      # Update samples parameter with filtered samples
      if (is.null(samples)) {
        samples <- filtered_samples
      } else {
        samples <- intersect(samples, filtered_samples)
        if (length(samples) == 0) {
          warning("No samples match both the specified filters and sample list")
          if (return_data) {
            return(matrix(nrow = 0, ncol = 0))
          } else {
            object@treatmentResponse[["drug"]] <- matrix(nrow = 0, ncol = 0)
            return(object)
          }
        }
      }
    }
  }

  # Construct query
  query <- paste0("SELECT * FROM ", table_name)

  # Add drug filter if specified
  if (!is.null(drugs)) {
    # First check if all drugs exist in the database
    drug_check_query <- paste0("SELECT DISTINCT feature_id FROM ", table_name)
    all_drugs <- DBI::dbGetQuery(con, drug_check_query)$feature_id

    missing_drugs <- setdiff(drugs, all_drugs)
    if (length(missing_drugs) > 0) {
      warning("The following drugs do not exist in the treatment response data: ",
              paste(missing_drugs, collapse = ", "))
    }

    # Only query for drugs that exist
    existing_drugs <- intersect(drugs, all_drugs)
    if (length(existing_drugs) == 0) {
      warning("None of the specified drugs exist in the treatment response data")
      if (return_data) {
        return(matrix(nrow = 0, ncol = 0))
      } else {
        object@treatmentResponse[["drug"]] <- matrix(nrow = 0, ncol = 0)
        return(object)
      }
    }

    drugs_str <- paste0("'", existing_drugs, "'", collapse = ",")
    query <- paste0(query, " WHERE feature_id IN (", drugs_str, ")")
  }

  # Execute query
  data <- DBI::dbGetQuery(con, query)

  # Variable to store the loaded data
  loaded_data <- NULL

  # Reshape to matrix format
  if (nrow(data) > 0) {
    # Extract feature_id column (drug names)
    drug_ids <- data$feature_id
    data$feature_id <- NULL

    # Convert to matrix
    mat <- as.matrix(data)
    rownames(mat) <- drug_ids

    # Filter by samples if needed
    if (!is.null(samples)) {
      # Check for missing samples
      missing_samples <- setdiff(samples, colnames(mat))
      if (length(missing_samples) > 0) {
        warning("The following samples do not exist in the treatment response data: ",
                paste(missing_samples, collapse = ", "))
      }

      common_samples <- intersect(colnames(mat), samples)
      if (length(common_samples) == 0) {
        warning("No samples match the specified filter")
        mat <- matrix(nrow = 0, ncol = 0)
      } else {
        mat <- mat[, common_samples, drop = FALSE]
      }
    }

    # Store the loaded data
    loaded_data <- mat

    # Store in object if not returning data directly
    if (!return_data) {
      object@treatmentResponse[["drug"]] <- mat
    }
  } else {
    warning("No data found for treatment response")
    loaded_data <- matrix(nrow = 0, ncol = 0)

    if (!return_data) {
      object@treatmentResponse[["drug"]] <- matrix(nrow = 0, ncol = 0)
    }
  }

  # Return either the updated object or the loaded data
  if (return_data) {
    return(loaded_data)
  } else {
    return(object)
  }
})



================================================
FILE: R/DromaSet-database.R
================================================
#' Create a DromaSet from Database
#'
#' @description Creates a DromaSet object linked to data in a SQLite database
#' @param project_name The name of the project/dataset (e.g., "gCSI", "CCLE")
#' @param db_path Path to the SQLite database
#' @param db_group Optional group name in the database, if different from project_name
#' @param load_metadata Logical, whether to load sample and treatment metadata (default: TRUE)
#' @param dataset_type Optional dataset type (e.g., "CellLine", "PDX", "PDO")
#' @param auto_load Logical, whether to automatically load treatment response and molecular profiles (default: FALSE)
#' @return A DromaSet object linked to the database
#' @export
#' @examples
#' \dontrun{
#' # Create a DromaSet for gCSI data from database
#' gCSI <- createDromaSetFromDatabase("gCSI", "~/droma.sqlite")
#'
#' # Create a DromaSet and automatically load drug response data
#' gCSI <- createDromaSetFromDatabase("gCSI", "~/droma.sqlite", auto_load = TRUE)
#' }
createDromaSetFromDatabase <- function(project_name, db_path = file.path(path.expand("~"), "droma.sqlite"),
                                    db_group = NULL, load_metadata = TRUE, dataset_type = NULL, auto_load = FALSE) {

  if (!file.exists(db_path)) {
    stop("Database file not found: ", db_path)
  }

  # Set db_group to project_name if not specified
  if (is.null(db_group)) {
    db_group <- project_name
  }

  # Connect to database
  con <- DBI::dbConnect(RSQLite::SQLite(), db_path)
  on.exit(DBI::dbDisconnect(con), add = TRUE)

  # Check if tables exist for this project
  all_tables <- DBI::dbListTables(con)
  project_tables <- grep(paste0("^", db_group, "_"), all_tables, value = TRUE)

  if (length(project_tables) == 0) {
    stop("No tables found for project '", project_name, "' with group prefix '", db_group, "'")
  }

  # Load metadata if requested
  sample_metadata <- data.frame()
  treatment_metadata <- data.frame()

  if (load_metadata) {
    # Try to load sample metadata
    if ("sample_anno" %in% all_tables) {
      # Get sample IDs from project tables - handle both continuous and discrete data
      sample_ids <- character()

      for (table in project_tables) {
        tryCatch({
          # Check if this is a discrete data table (mutation, fusion)
          table_info <- DBI::dbGetQuery(con, paste0("SELECT name FROM pragma_table_info('", table, "')"))
          column_names <- table_info$name

          if ("samples" %in% column_names || "cells" %in% column_names) {
            # Discrete data - samples are in a column
            sample_col <- ifelse("samples" %in% column_names, "samples", "cells")
            sample_query_discrete <- paste0("SELECT DISTINCT ", sample_col, " FROM ", table)
            discrete_samples <- DBI::dbGetQuery(con, sample_query_discrete)[[sample_col]]
            sample_ids <- c(sample_ids, discrete_samples)
          } else {
            # Continuous data - samples are column names (excluding feature_id)
            continuous_samples <- setdiff(column_names, "feature_id")
            sample_ids <- c(sample_ids, continuous_samples)
          }
        }, error = function(e) {
          warning("Problem with getting sample IDs from table '", table, "': ", e$message)
        })
      }

      # Get unique sample IDs
      sample_ids <- unique(sample_ids)

      if (length(sample_ids) > 0) {
        # Construct query to get sample metadata for these samples
        sample_ids_str <- paste0("'", sample_ids, "'", collapse = ",")
        sample_query <- paste0("SELECT * FROM sample_anno WHERE SampleID IN (", sample_ids_str, ")")

        tryCatch({
          sample_metadata <- DBI::dbGetQuery(con, sample_query)
          # Filter by project if ProjectID column exists
          if ("ProjectID" %in% colnames(sample_metadata)) {
            sample_metadata <- sample_metadata[sample_metadata$ProjectID %in% project_name, ]
          }
          sample_metadata <- unique(sample_metadata)
        }, error = function(e) {
          warning("Problem with loading sample metadata: ", e$message)
        })
      }
    }

    # Try to load treatment metadata
    if ("drug_anno" %in% all_tables) {
      # Construct query to get drugs for this project
      drug_query <- paste0(
        "SELECT * FROM drug_anno WHERE DrugName IN (",
        "SELECT feature_id FROM ", db_group, "_drug)"
      )

      tryCatch({
        treatment_metadata <- DBI::dbGetQuery(con, drug_query)
        treatment_metadata <- treatment_metadata[treatment_metadata$ProjectID %in% project_name,]
        treatment_metadata <- unique(treatment_metadata)
      }, error = function(e) {
        warning("Problem with loading treatment metadata: ", e$message)
      })
    }
  }

  # If dataset_type is not provided, try to infer from sample metadata
  if (is.null(dataset_type) && nrow(sample_metadata) > 0 && "DataType" %in% colnames(sample_metadata)) {
    dataset_type <- unique(sample_metadata$DataType)[1]
  }

  # Create the DromaSet object
  object <- DromaSet(
    name = project_name,
    sampleMetadata = sample_metadata,
    treatmentMetadata = treatment_metadata,
    datasetType = ifelse(is.null(dataset_type), NA_character_, dataset_type),
    db_info = list(
      db_path = db_path,
      db_group = db_group
    )
  )

  # Auto-load treatment response and molecular profiles if requested
  if (auto_load) {
    # Load treatment response data if available
    if (paste0(db_group, "_drug") %in% all_tables) {
      tryCatch({
        object <- loadTreatmentResponse(object)
        message("Loaded treatment response data for project '", project_name, "'")
      }, error = function(e) {
        warning("Problem with loading treatment response data: ", e$message)
      })
    }

    # Get molecular profile types available for this project
    profile_types <- unique(sapply(project_tables, function(t) {
      sub(paste0("^", db_group, "_"), "", t)
    }))
    # Remove drug table from profile types
    profile_types <- setdiff(profile_types, "drug")

    if (length(profile_types) > 0) {
      for (profile_type in profile_types) {
        tryCatch({
          object <- loadMolecularProfiles(object, molecular_type = profile_type)
          message("Loaded '", profile_type, "' molecular profile data for project '", project_name, "'")
        }, error = function(e) {
          warning("Problem with loading '", profile_type, "' molecular profile data: ", e$message)
        })
      }
    }
  }

  return(object)
}



================================================
FILE: R/MultiDromaSet-class.R
================================================
#' MultiDromaSet Class
#'
#' @description A class to represent multiple DROMA projects with drug response and omics data.
#' Each MultiDromaSet contains multiple DromaSet objects, allowing for cross-project analyses
#' and handling of overlapping samples between different datasets.
#'
#' @slot name Character vector, the names of the projects included in this MultiDromaSet
#' @slot DromaSets List containing DromaSet objects for each project
#' @slot sampleMetadata Data frame with merged sample annotations from all projects
#' @slot treatmentMetadata Data frame with merged drug annotations from all projects
#' @slot datasetType Character vector, the types of datasets included (e.g., "CellLine", "PDX", "PDO")
#' @slot db_info List containing database connection information
#' @export
setClass("MultiDromaSet",
  slots = c(
    name = "character",
    DromaSets = "list",
    sampleMetadata = "data.frame",
    treatmentMetadata = "data.frame",
    datasetType = "character",
    db_info = "list"
  ),
  prototype = list(
    name = character(),
    DromaSets = list(),
    sampleMetadata = data.frame(),
    treatmentMetadata = data.frame(),
    datasetType = character(),
    db_info = list()
  )
)

#' Create a MultiDromaSet Object
#'
#' @description Creates a MultiDromaSet object to store multiple DromaSet objects for cross-project analysis
#' @param name Character vector, the names of the projects included
#' @param DromaSets List containing DromaSet objects for each project
#' @param sampleMetadata Data frame with merged sample annotations (optional, will be merged from DromaSets if not provided)
#' @param treatmentMetadata Data frame with merged drug annotations (optional, will be merged from DromaSets if not provided)
#' @param datasetType Character vector, the types of datasets included (optional, will be inferred from DromaSets if not provided)
#' @param db_info List containing database connection information
#' @return A MultiDromaSet object
#' @export
#' @examples
#' \dontrun{
#' # Create individual DromaSet objects
#' gCSI <- createDromaSetFromDatabase("gCSI", "~/droma.sqlite")
#' CCLE <- createDromaSetFromDatabase("CCLE", "~/droma.sqlite")
#'
#' # Create a MultiDromaSet object
#' multi_set <- MultiDromaSet(
#'   name = c("gCSI", "CCLE"),
#'   DromaSets = list(gCSI = gCSI, CCLE = CCLE)
#' )
#' }
MultiDromaSet <- function(name,
                         DromaSets = list(),
                         sampleMetadata = data.frame(),
                         treatmentMetadata = data.frame(),
                         datasetType = character(),
                         db_info = list()) {

  # Validate inputs
  if (length(DromaSets) > 0) {
    # Check that all elements are DromaSet objects
    if (!all(sapply(DromaSets, function(x) inherits(x, "DromaSet")))) {
      stop("All elements in DromaSets must be DromaSet objects")
    }

    # If name not provided, extract from DromaSets
    if (missing(name) || length(name) == 0) {
      name <- sapply(DromaSets, function(x) x@name)
    }

    # Ensure names match
    if (length(name) != length(DromaSets)) {
      stop("Length of name must match length of DromaSets")
    }

    # Set names for DromaSets list
    if (is.null(names(DromaSets))) {
      names(DromaSets) <- name
    }

    # Merge metadata if not provided
    if (nrow(sampleMetadata) == 0) {
      sampleMetadata <- mergeSampleMetadata(DromaSets)
    }

    if (nrow(treatmentMetadata) == 0) {
      treatmentMetadata <- mergeTreatmentMetadata(DromaSets)
    }

    # Infer datasetType if not provided
    if (length(datasetType) == 0) {
      datasetType <- unique(sapply(DromaSets, function(x) x@datasetType))
      datasetType <- datasetType[!is.na(datasetType)]
    }

    # Merge db_info if not provided
    if (length(db_info) == 0) {
      db_paths <- unique(sapply(DromaSets, function(x) x@db_info$db_path))
      db_paths <- db_paths[!is.null(db_paths)]
      if (length(db_paths) > 0) {
        db_info <- list(db_path = db_paths[1])  # Use first database path
      }
    }
  }

  # Create new MultiDromaSet object
  object <- new("MultiDromaSet",
              name = name,
              DromaSets = DromaSets,
              sampleMetadata = sampleMetadata,
              treatmentMetadata = treatmentMetadata,
              datasetType = datasetType,
              db_info = db_info)

  # Return the object
  return(object)
}

#' Helper function to merge sample metadata from multiple DromaSets
#' @param DromaSets List of DromaSet objects
#' @return Merged data frame of sample metadata
mergeSampleMetadata <- function(DromaSets) {
  if (length(DromaSets) == 0) {
    return(data.frame())
  }

  # Extract sample metadata from each DromaSet
  sample_list <- lapply(names(DromaSets), function(proj_name) {
    ds <- DromaSets[[proj_name]]
    if (nrow(ds@sampleMetadata) > 0) {
      # Add ProjectID column to track source
      metadata <- ds@sampleMetadata
      metadata$ProjectID <- proj_name
      return(metadata)
    } else {
      return(NULL)
    }
  })

  # Remove NULL entries
  sample_list <- sample_list[!sapply(sample_list, is.null)]

  if (length(sample_list) == 0) {
    return(data.frame())
  }

  # Merge all sample metadata (keep all entries, don't remove duplicates)
  merged_samples <- do.call(rbind, sample_list)

  return(merged_samples)
}

#' Helper function to merge treatment metadata from multiple DromaSets
#' @param DromaSets List of DromaSet objects
#' @return Merged data frame of treatment metadata
mergeTreatmentMetadata <- function(DromaSets) {
  if (length(DromaSets) == 0) {
    return(data.frame())
  }

  # Extract treatment metadata from each DromaSet
  treatment_list <- lapply(names(DromaSets), function(proj_name) {
    ds <- DromaSets[[proj_name]]
    if (nrow(ds@treatmentMetadata) > 0) {
      # Add ProjectID column to track source
      metadata <- ds@treatmentMetadata
      metadata$ProjectID <- proj_name
      return(metadata)
    } else {
      return(NULL)
    }
  })

  # Remove NULL entries
  treatment_list <- treatment_list[!sapply(treatment_list, is.null)]

  if (length(treatment_list) == 0) {
    return(data.frame())
  }

  # Merge all treatment metadata (keep all entries, don't remove duplicates)
  merged_treatments <- do.call(rbind, treatment_list)

  return(merged_treatments)
}

#' Show Method for MultiDromaSet objects
#'
#' @description Displays information about a MultiDromaSet object
#' @param object A MultiDromaSet object
#' @return NULL, prints information to console
#' @export
setMethod("show", "MultiDromaSet", function(object) {
  cat("MultiDromaSet Object\n")
  cat("Projects:", paste(object@name, collapse = ", "), "\n")
  cat("Dataset Types:", paste(unique(object@datasetType), collapse = ", "), "\n\n")

  # Show information for each DromaSet
  cat("Individual DromaSets:\n")
  for (i in seq_along(object@DromaSets)) {
    ds <- object@DromaSets[[i]]
    cat("  ", names(object@DromaSets)[i], ":\n")

    # Treatment Response
    if (length(ds@treatmentResponse) > 0) {
      tr_info <- lapply(ds@treatmentResponse, function(x) {
        if(is.matrix(x) || is.data.frame(x)) {
          paste0("(", nrow(x), " drugs x ", ncol(x), " samples)")
        } else {
          "(data in database)"
        }
      })
      cat("    Treatment Response:", paste(names(ds@treatmentResponse), tr_info, sep = ": ", collapse = ", "), "\n")
    } else {
      cat("    Treatment Response: None loaded\n")
    }

    # Molecular Profiles
    if (length(ds@molecularProfiles) > 0) {
      mp_info <- lapply(ds@molecularProfiles, function(x) {
        if(is.matrix(x) || is.data.frame(x)) {
          paste0("(", nrow(x), " features x ", ncol(x), " samples)")
        } else {
          "(data in database)"
        }
      })
      cat("    Molecular Profiles:", paste(names(ds@molecularProfiles), mp_info, sep = ": ", collapse = ", "), "\n")
    } else {
      cat("    Molecular Profiles: None loaded\n")
    }
  }

  # Sample overlap information
  cat("\nSample Information:\n")
  if (nrow(object@sampleMetadata) > 0) {
    # Get unique samples across all projects
    unique_samples <- length(unique(object@sampleMetadata$SampleID))
    total_samples <- nrow(object@sampleMetadata)
    cat("  Total unique samples:", unique_samples, "\n")

    # Show sample overlap between projects
    if (length(object@DromaSets) > 1) {
      sample_lists <- lapply(object@DromaSets, function(ds) {
        if (nrow(ds@sampleMetadata) > 0) {
          return(ds@sampleMetadata$SampleID)
        } else {
          return(character(0))
        }
      })

      cat("  Sample counts per project:\n")
      for (i in seq_along(sample_lists)) {
        cat("    ", names(sample_lists)[i], ":", length(sample_lists[[i]]), "samples\n")
      }

      # Show pairwise overlaps
      if (length(sample_lists) == 2) {
        overlap_count <- length(intersect(sample_lists[[1]], sample_lists[[2]]))
        cat("  Overlapping samples between projects:", overlap_count, "\n")
      }
    }
  } else {
    cat("  No sample metadata available\n")
  }

  # Treatment overlap information
  cat("\nTreatment Information:\n")
  if (nrow(object@treatmentMetadata) > 0) {
    # Get unique drugs across all projects
    unique_drugs <- length(unique(object@treatmentMetadata$DrugName))
    total_drugs <- nrow(object@treatmentMetadata)
    cat("  Total unique drugs:", unique_drugs, "\n")

    # Show drug overlap between projects
    if (length(object@DromaSets) > 1) {
      drug_lists <- lapply(object@DromaSets, function(ds) {
        if (nrow(ds@treatmentMetadata) > 0) {
          return(ds@treatmentMetadata$DrugName)
        } else {
          return(character(0))
        }
      })

      cat("  Drug counts per project:\n")
      for (i in seq_along(drug_lists)) {
        cat("    ", names(drug_lists)[i], ":", length(drug_lists[[i]]), "drugs\n")
      }

      # Show pairwise overlaps for drugs
      if (length(drug_lists) == 2) {
        overlap_count <- length(intersect(drug_lists[[1]], drug_lists[[2]]))
        cat("  Overlapping drugs between projects:", overlap_count, "\n")
      }
    }
  } else {
    cat("  No treatment metadata available\n")
  }

  # Database information
  cat("\nDatabase Connection Information:\n")
  if (length(object@db_info) > 0) {
    cat("  Path:", ifelse(is.null(object@db_info$db_path), "Not specified", object@db_info$db_path), "\n")
  } else {
    cat("  No database information available\n")
  }

  invisible(NULL)
})

#' Get Available Projects in MultiDromaSet
#'
#' @description Returns the names of projects available in a MultiDromaSet
#' @param object A MultiDromaSet object
#' @return Character vector of project names
#' @export
setGeneric("availableProjects", function(object) standardGeneric("availableProjects"))

#' @rdname availableProjects
#' @export
setMethod("availableProjects", "MultiDromaSet", function(object) {
  return(object@name)
})

#' Get DromaSet by Project Name
#'
#' @description Retrieves a specific DromaSet from a MultiDromaSet by project name
#' @param object A MultiDromaSet object
#' @param project_name Character, the name of the project to retrieve
#' @return A DromaSet object
#' @export
setGeneric("getDromaSet", function(object, project_name) standardGeneric("getDromaSet"))

#' @rdname getDromaSet
#' @export
setMethod("getDromaSet", "MultiDromaSet", function(object, project_name) {
  if (!project_name %in% object@name) {
    stop("Project '", project_name, "' not found. Available projects: ", paste(object@name, collapse = ", "))
  }

  return(object@DromaSets[[project_name]])
})

#' Get Overlapping Samples Between Projects
#'
#' @description Finds samples that are present in multiple projects within a MultiDromaSet
#' @param object A MultiDromaSet object
#' @param projects Character vector, specific projects to check for overlap (default: all projects)
#' @return A list containing overlapping sample information
#' @export
setGeneric("getOverlappingSamples", function(object, projects = NULL) standardGeneric("getOverlappingSamples"))

#' @rdname getOverlappingSamples
#' @export
setMethod("getOverlappingSamples", "MultiDromaSet", function(object, projects = NULL) {
  if (is.null(projects)) {
    projects <- object@name
  }

  # Validate project names
  invalid_projects <- setdiff(projects, object@name)
  if (length(invalid_projects) > 0) {
    stop("Invalid project names: ", paste(invalid_projects, collapse = ", "))
  }

  if (length(projects) < 2) {
    stop("At least 2 projects are required to find overlaps")
  }

  # Get sample lists for each project
  sample_lists <- lapply(projects, function(proj) {
    ds <- object@DromaSets[[proj]]
    if (nrow(ds@sampleMetadata) > 0) {
      return(ds@sampleMetadata$SampleID)
    } else {
      return(character(0))
    }
  })
  names(sample_lists) <- projects

  # Find overlapping samples
  if (length(projects) == 2) {
    # For two projects, simple intersection
    overlap <- intersect(sample_lists[[1]], sample_lists[[2]])
    result <- list(
      projects = projects,
      overlapping_samples = overlap,
      overlap_count = length(overlap),
      project_sample_counts = sapply(sample_lists, length)
    )
  } else {
    # For multiple projects, find samples present in all projects
    overlap <- Reduce(intersect, sample_lists)
    result <- list(
      projects = projects,
      overlapping_samples = overlap,
      overlap_count = length(overlap),
      project_sample_counts = sapply(sample_lists, length),
      pairwise_overlaps = combn(projects, 2, function(pair) {
        list(
          projects = pair,
          overlap = intersect(sample_lists[[pair[1]]], sample_lists[[pair[2]]]),
          count = length(intersect(sample_lists[[pair[1]]], sample_lists[[pair[2]]]))
        )
      }, simplify = FALSE)
    )
  }

  return(result)
})

#' Load Molecular Profiles Across Multiple Projects
#'
#' @description Loads molecular profiles from multiple projects,
#' returning only data for overlapping samples
#' @param object A MultiDromaSet object
#' @param molecular_type Character, the type to load (e.g., "mRNA", "cnv") or "all" to load all available types
#' @param features Character vector, specific features to load (optional)
#' @param projects Character vector, specific projects to load from (default: all projects)
#' @param overlap_only Logical, whether to return only overlapping samples (default: FALSE)
#' @param data_type Filter by data type: "all" (default), "CellLine", "PDO" (patient-derived organoids), "PDC", or "PDX"
#' @param tumor_type Filter by tumor type: "all" (default) or any specific tumor type (e.g., "lung cancer", "breast cancer")
#' @return A list containing molecular profile matrices from each project
#' @export
setGeneric("loadMultiProjectMolecularProfiles", function(object, molecular_type, features = NULL, projects = NULL, overlap_only = FALSE, data_type = "all", tumor_type = "all")
  standardGeneric("loadMultiProjectMolecularProfiles"))

#' @rdname loadMultiProjectMolecularProfiles
#' @export
setMethod("loadMultiProjectMolecularProfiles", "MultiDromaSet", function(object, molecular_type, features = NULL, projects = NULL, overlap_only = FALSE, data_type = "all", tumor_type = "all") {
  if (is.null(projects)) {
    projects <- object@name
  }

  # Validate project names
  invalid_projects <- setdiff(projects, object@name)
  if (length(invalid_projects) > 0) {
    stop("Invalid project names: ", paste(invalid_projects, collapse = ", "))
  }

  # Handle "all" molecular_type option
  if (molecular_type == "all") {
    # Get all available molecular types across all projects
    all_mol_types <- character()
    for (proj in projects) {
      ds <- object@DromaSets[[proj]]
      proj_types <- availableMolecularProfiles(ds, include_db = TRUE)
      all_mol_types <- unique(c(all_mol_types, proj_types))
    }

    if (length(all_mol_types) == 0) {
      stop("No molecular profile types found across the specified projects")
    }

    # Load each molecular type separately
    all_results <- list()

    for (mol_type in all_mol_types) {
      message("Loading molecular profile type: ", mol_type)

      tryCatch({
        mol_results <- loadMultiProjectMolecularProfiles(
          object = object,
          molecular_type = mol_type,
          features = features,
          projects = projects,
          overlap_only = overlap_only,
          data_type = data_type,
          tumor_type = tumor_type
        )

        # Store results with molecular type as top-level key
        all_results[[mol_type]] <- mol_results

      }, error = function(e) {
        warning("Failed to load molecular profile '", mol_type, "': ", e$message)
      })
    }

    message("Loaded ", length(all_results), " molecular profile types across ",
            length(projects), " projects")
    return(all_results)
  }

  # Original single molecular_type loading logic
  # Load data from each project
  data_list <- list()

  for (proj in projects) {
    ds <- object@DromaSets[[proj]]

    tryCatch({
      data_list[[proj]] <- loadMolecularProfiles(ds, molecular_type = molecular_type,
                                                features = features, return_data = TRUE,
                                                data_type = data_type, tumor_type = tumor_type)
    }, error = function(e) {
      warning("Problem with loading molecular profiles from project '", proj, "': ", e$message)
      data_list[[proj]] <- NULL
    })
  }

  # Remove NULL entries
  data_list <- data_list[!sapply(data_list, is.null)]

  if (length(data_list) == 0) {
    stop("No molecular profile data could be loaded from any project")
  }

  # If overlap_only is TRUE, filter to overlapping samples
  if (overlap_only && length(data_list) > 1) {
    # Get sample names from each dataset
    sample_lists <- lapply(data_list, function(x) {
      if (is.matrix(x) || is.data.frame(x)) {
        return(colnames(x))
      } else {
        return(character(0))
      }
    })

    # Find overlapping samples
    overlapping_samples <- Reduce(intersect, sample_lists)

    if (length(overlapping_samples) == 0) {
      warning("No overlapping samples found between projects. Return all data.")
      return(data_list)
    }

    # Filter each dataset to overlapping samples
    data_list <- lapply(data_list, function(x) {
      if (is.matrix(x) || is.data.frame(x)) {
        common_samples <- intersect(colnames(x), overlapping_samples)
        if (length(common_samples) > 0) {
          return(x[, common_samples, drop = FALSE])
        }
      }
      return(x)
    })

    message("Filtered molecular profile data to ", length(overlapping_samples), " overlapping samples")
  }

  return(data_list)
})

#' Load Treatment Response Across Multiple Projects
#'
#' @description Loads treatment response data from multiple projects,
#' returning only data for overlapping samples
#' @param object A MultiDromaSet object
#' @param drugs Character vector, specific drugs to load (optional)
#' @param projects Character vector, specific projects to load from (default: all projects)
#' @param overlap_only Logical, whether to return only overlapping samples (default: FALSE)
#' @param data_type Filter by data type: "all" (default), "CellLine", "PDO" (patient-derived organoids), "PDC", or "PDX"
#' @param tumor_type Filter by tumor type: "all" (default) or any specific tumor type (e.g., "lung cancer", "breast cancer")
#' @return A list containing treatment response matrices from each project
#' @export
setGeneric("loadMultiProjectTreatmentResponse", function(object, drugs = NULL, projects = NULL, overlap_only = FALSE, data_type = "all", tumor_type = "all")
  standardGeneric("loadMultiProjectTreatmentResponse"))

#' @rdname loadMultiProjectTreatmentResponse
#' @export
setMethod("loadMultiProjectTreatmentResponse", "MultiDromaSet", function(object, drugs = NULL, projects = NULL, overlap_only = FLASE, data_type = "all", tumor_type = "all") {
  if (is.null(projects)) {
    projects <- object@name
  }

  # Validate project names
  invalid_projects <- setdiff(projects, object@name)
  if (length(invalid_projects) > 0) {
    stop("Invalid project names: ", paste(invalid_projects, collapse = ", "))
  }

  # Load data from each project
  data_list <- list()

  for (proj in projects) {
    ds <- object@DromaSets[[proj]]

    tryCatch({
      data_list[[proj]] <- loadTreatmentResponse(ds, drugs = drugs, return_data = TRUE,
                                                data_type = data_type, tumor_type = tumor_type)
    }, error = function(e) {
      warning("Problem with loading treatment response from project '", proj, "': ", e$message)
      data_list[[proj]] <- NULL
    })
  }

  # Remove NULL entries
  data_list <- data_list[!sapply(data_list, is.null)]

  if (length(data_list) == 0) {
    stop("No treatment response data could be loaded from any project")
  }

  # If overlap_only is TRUE, filter to overlapping samples
  if (overlap_only && length(data_list) > 1) {
    # Get sample names from each dataset
    sample_lists <- lapply(data_list, function(x) {
      if (is.matrix(x) || is.data.frame(x)) {
        return(colnames(x))
      } else {
        return(character(0))
      }
    })

    # Find overlapping samples
    overlapping_samples <- Reduce(intersect, sample_lists)

    if (length(overlapping_samples) == 0) {
      warning("No overlapping samples found between projects. Return all data.")
      return(data_list)
    }

    # Filter each dataset to overlapping samples
    data_list <- lapply(data_list, function(x) {
      if (is.matrix(x) || is.data.frame(x)) {
        common_samples <- intersect(colnames(x), overlapping_samples)
        if (length(common_samples) > 0) {
          return(x[, common_samples, drop = FALSE])
        }
      }
      return(x)
    })

    message("Filtered treatment response data to ", length(overlapping_samples), " overlapping samples")
  }

  return(data_list)
})



================================================
FILE: R/MultiDromaSet-database.R
================================================
#' Create a MultiDromaSet from Database
#'
#' @description Creates a MultiDromaSet object containing multiple projects from a SQLite database
#' @param project_names Character vector, the names of the projects/datasets to include (e.g., c("gCSI", "CCLE"))
#' @param db_path Path to the SQLite database
#' @param db_groups Optional character vector of group names in the database, if different from project_names
#' @param load_metadata Logical, whether to load sample and treatment metadata (default: TRUE)
#' @param dataset_types Optional character vector of dataset types for each project (e.g., c("CellLine", "PDX"))
#' @param auto_load Logical, whether to automatically load treatment response and molecular profiles (default: FALSE)
#' @return A MultiDromaSet object linked to the database
#' @export
#' @examples
#' \dontrun{
#' # Create a MultiDromaSet for gCSI and CCLE data from database
#' multi_set <- createMultiDromaSetFromDatabase(c("gCSI", "CCLE"), "~/droma.sqlite")
#'
#' # Create a MultiDromaSet and automatically load all data
#' multi_set <- createMultiDromaSetFromDatabase(c("gCSI", "CCLE"), "~/droma.sqlite", auto_load = TRUE)
#'
#' # Create with specific dataset types
#' multi_set <- createMultiDromaSetFromDatabase(
#'   project_names = c("gCSI", "PDX_data"),
#'   db_path = "~/droma.sqlite",
#'   dataset_types = c("CellLine", "PDX")
#' )
#' }
createMultiDromaSetFromDatabase <- function(project_names,
                                          db_path = file.path(path.expand("~"), "droma.sqlite"),
                                          db_groups = NULL,
                                          load_metadata = TRUE,
                                          dataset_types = NULL,
                                          auto_load = FALSE) {

  if (!file.exists(db_path)) {
    stop("Database file not found: ", db_path)
  }

  if (length(project_names) == 0) {
    stop("At least one project name must be provided")
  }

  # Set db_groups to project_names if not specified
  if (is.null(db_groups)) {
    db_groups <- project_names
  }

  if (length(db_groups) != length(project_names)) {
    stop("Length of db_groups must match length of project_names")
  }

  # Set dataset_types if not provided
  if (is.null(dataset_types)) {
    dataset_types <- rep(NA_character_, length(project_names))
  }

  if (length(dataset_types) != length(project_names)) {
    stop("Length of dataset_types must match length of project_names")
  }

  # Connect to database to validate projects exist
  con <- DBI::dbConnect(RSQLite::SQLite(), db_path)
  on.exit(DBI::dbDisconnect(con), add = TRUE)

  all_tables <- DBI::dbListTables(con)

  # Validate that each project has tables in the database
  for (i in seq_along(project_names)) {
    project_tables <- grep(paste0("^", db_groups[i], "_"), all_tables, value = TRUE)
    if (length(project_tables) == 0) {
      stop("No tables found for project '", project_names[i], "' with group prefix '", db_groups[i], "'")
    }
  }

  # Create individual DromaSet objects for each project
  droma_sets <- list()

  for (i in seq_along(project_names)) {
    message("Creating DromaSet for project: ", project_names[i])

    tryCatch({
      ds <- createDromaSetFromDatabase(
        project_name = project_names[i],
        db_path = db_path,
        db_group = db_groups[i],
        load_metadata = load_metadata,
        dataset_type = dataset_types[i],
        auto_load = auto_load
      )
      droma_sets[[project_names[i]]] <- ds
    }, error = function(e) {
      warning("Problem with creating DromaSet for project '", project_names[i], "': ", e$message)
    })
  }

  if (length(droma_sets) == 0) {
    stop("No DromaSet objects could be created from the specified projects")
  }

  # Create the MultiDromaSet object
  multi_set <- MultiDromaSet(
    name = names(droma_sets),
    DromaSets = droma_sets,
    db_info = list(db_path = db_path)
  )

  message("Created MultiDromaSet with ", length(droma_sets), " projects: ",
          paste(names(droma_sets), collapse = ", "))

  return(multi_set)
}

#' Create a MultiDromaSet from Existing DromaSet Objects
#'
#' @description Creates a MultiDromaSet object from a list of existing DromaSet objects
#' @param droma_sets List of DromaSet objects or individual DromaSet objects passed as separate arguments
#' @param project_names Optional character vector of project names (will be extracted from DromaSet objects if not provided)
#' @param merge_metadata Logical, whether to merge sample and treatment metadata from all DromaSets (default: TRUE)
#' @return A MultiDromaSet object
#' @export
#' @examples
#' \dontrun{
#' # Create individual DromaSet objects
#' gCSI <- createDromaSetFromDatabase("gCSI", "~/droma.sqlite")
#' CCLE <- createDromaSetFromDatabase("CCLE", "~/droma.sqlite")
#'
#' # Method 1: Pass as a list
#' multi_set <- createMultiDromaSetFromObjects(list(gCSI = gCSI, CCLE = CCLE))
#'
#' # Method 2: Pass as separate arguments
#' multi_set <- createMultiDromaSetFromObjects(gCSI, CCLE)
#'
#' # Method 3: Specify custom project names
#' multi_set <- createMultiDromaSetFromObjects(
#'   list(gCSI, CCLE),
#'   project_names = c("Genomics_CSI", "Cancer_Cell_Lines")
#' )
#' }
createMultiDromaSetFromObjects <- function(..., project_names = NULL, merge_metadata = TRUE) {

  # Handle different input formats
  args <- list(...)

  if (length(args) == 1 && is.list(args[[1]]) && !inherits(args[[1]], "DromaSet")) {
    # Input is a single list of DromaSet objects
    droma_sets <- args[[1]]
  } else {
    # Input is individual DromaSet objects
    droma_sets <- args
  }

  if (length(droma_sets) == 0) {
    stop("At least one DromaSet object must be provided")
  }

  # Validate that all inputs are DromaSet objects
  if (!all(sapply(droma_sets, function(x) inherits(x, "DromaSet")))) {
    stop("All inputs must be DromaSet objects")
  }

  # Extract project names if not provided
  if (is.null(project_names)) {
    if (is.null(names(droma_sets))) {
      # Extract names from DromaSet objects
      project_names <- sapply(droma_sets, function(x) x@name)
    } else {
      # Use list names
      project_names <- names(droma_sets)
    }
  }

  # Validate project names
  if (length(project_names) != length(droma_sets)) {
    stop("Length of project_names must match number of DromaSet objects")
  }

  # Set names for the list
  names(droma_sets) <- project_names

  # Check for duplicate project names
  if (any(duplicated(project_names))) {
    stop("Duplicate project names found: ", paste(project_names[duplicated(project_names)], collapse = ", "))
  }

  # Create the MultiDromaSet object
  if (merge_metadata) {
    multi_set <- MultiDromaSet(
      name = project_names,
      DromaSets = droma_sets
    )
  } else {
    # Don't merge metadata, create empty metadata
    multi_set <- MultiDromaSet(
      name = project_names,
      DromaSets = droma_sets,
      sampleMetadata = data.frame(),
      treatmentMetadata = data.frame()
    )
  }

  message("Created MultiDromaSet with ", length(droma_sets), " projects: ",
          paste(project_names, collapse = ", "))

  return(multi_set)
}

#' Add DromaSet to Existing MultiDromaSet
#'
#' @description Adds a new DromaSet object to an existing MultiDromaSet
#' @param multi_set A MultiDromaSet object
#' @param droma_set A DromaSet object to add
#' @param project_name Optional character, name for the new project (will use DromaSet name if not provided)
#' @param update_metadata Logical, whether to update merged metadata (default: TRUE)
#' @return Updated MultiDromaSet object
#' @export
#' @examples
#' \dontrun{
#' # Create initial MultiDromaSet
#' multi_set <- createMultiDromaSetFromDatabase(c("gCSI", "CCLE"), "~/droma.sqlite")
#'
#' # Create a new DromaSet
#' new_set <- createDromaSetFromDatabase("GDSC", "~/droma.sqlite")
#'
#' # Add to MultiDromaSet
#' multi_set <- addDromaSetToMulti(multi_set, new_set)
#' }
addDromaSetToMulti <- function(multi_set, droma_set, project_name = NULL, update_metadata = TRUE) {

  if (!inherits(multi_set, "MultiDromaSet")) {
    stop("multi_set must be a MultiDromaSet object")
  }

  if (!inherits(droma_set, "DromaSet")) {
    stop("droma_set must be a DromaSet object")
  }

  # Get project name
  if (is.null(project_name)) {
    project_name <- droma_set@name
  }

  # Check if project already exists
  if (project_name %in% multi_set@name) {
    stop("Project '", project_name, "' already exists in MultiDromaSet. Use a different project_name or remove the existing project first.")
  }

  # Add the new DromaSet
  multi_set@DromaSets[[project_name]] <- droma_set
  multi_set@name <- c(multi_set@name, project_name)

  # Update metadata if requested
  if (update_metadata) {
    multi_set@sampleMetadata <- mergeSampleMetadata(multi_set@DromaSets)
    multi_set@treatmentMetadata <- mergeTreatmentMetadata(multi_set@DromaSets)

    # Update dataset types
    new_dataset_types <- unique(sapply(multi_set@DromaSets, function(x) x@datasetType))
    new_dataset_types <- new_dataset_types[!is.na(new_dataset_types)]
    multi_set@datasetType <- new_dataset_types
  }

  message("Added project '", project_name, "' to MultiDromaSet")

  return(multi_set)
}

#' Remove DromaSet from MultiDromaSet
#'
#' @description Removes a DromaSet object from an existing MultiDromaSet
#' @param multi_set A MultiDromaSet object
#' @param project_name Character, name of the project to remove
#' @param update_metadata Logical, whether to update merged metadata (default: TRUE)
#' @return Updated MultiDromaSet object
#' @export
#' @examples
#' \dontrun{
#' # Remove a project from MultiDromaSet
#' multi_set <- removeDromaSetFromMulti(multi_set, "CCLE")
#' }
removeDromaSetFromMulti <- function(multi_set, project_name, update_metadata = TRUE) {

  if (!inherits(multi_set, "MultiDromaSet")) {
    stop("multi_set must be a MultiDromaSet object")
  }

  if (!project_name %in% multi_set@name) {
    stop("Project '", project_name, "' not found in MultiDromaSet. Available projects: ",
         paste(multi_set@name, collapse = ", "))
  }

  if (length(multi_set@name) == 1) {
    stop("Cannot remove the last project from MultiDromaSet")
  }

  # Remove the DromaSet
  multi_set@DromaSets[[project_name]] <- NULL
  multi_set@name <- multi_set@name[multi_set@name != project_name]

  # Update metadata if requested
  if (update_metadata) {
    multi_set@sampleMetadata <- mergeSampleMetadata(multi_set@DromaSets)
    multi_set@treatmentMetadata <- mergeTreatmentMetadata(multi_set@DromaSets)

    # Update dataset types
    new_dataset_types <- unique(sapply(multi_set@DromaSets, function(x) x@datasetType))
    new_dataset_types <- new_dataset_types[!is.na(new_dataset_types)]
    multi_set@datasetType <- new_dataset_types
  }

  message("Removed project '", project_name, "' from MultiDromaSet")

  return(multi_set)
}

#' Create MultiDromaSet from All Available Projects in Database
#'
#' @description Creates a MultiDromaSet object containing all available projects found in a database
#' @param db_path Path to the SQLite database
#' @param exclude_projects Character vector of project names to exclude (optional)
#' @param include_projects Character vector of project names to include (if specified, only these will be included)
#' @param load_metadata Logical, whether to load sample and treatment metadata (default: TRUE)
#' @param auto_load Logical, whether to automatically load treatment response and molecular profiles (default: FALSE)
#' @return A MultiDromaSet object containing all available projects
#' @export
#' @examples
#' \dontrun{
#' # Create MultiDromaSet with all projects in database
#' multi_set <- createMultiDromaSetFromAllProjects("~/droma.sqlite")
#'
#' # Create MultiDromaSet excluding specific projects
#' multi_set <- createMultiDromaSetFromAllProjects("~/droma.sqlite",
#'                                                exclude_projects = c("test_project"))
#'
#' # Create MultiDromaSet with only specific projects
#' multi_set <- createMultiDromaSetFromAllProjects("~/droma.sqlite",
#'                                                include_projects = c("gCSI", "CCLE"))
#' }
createMultiDromaSetFromAllProjects <- function(db_path = file.path(path.expand("~"), "droma.sqlite"),
                                             exclude_projects = NULL,
                                             include_projects = NULL,
                                             load_metadata = TRUE,
                                             auto_load = FALSE) {

  if (!file.exists(db_path)) {
    stop("Database file not found: ", db_path)
  }

  # Get all available projects
  con <- connectDROMADatabase(db_path)
  on.exit(closeDROMADatabase(con), add = TRUE)

  all_projects <- listDROMAProjects(con, show_names_only = TRUE)

  if (length(all_projects) == 0) {
    stop("No projects found in database")
  }

  # Filter projects based on include/exclude criteria
  if (!is.null(include_projects)) {
    # Only include specified projects
    missing_projects <- setdiff(include_projects, all_projects)
    if (length(missing_projects) > 0) {
      warning("The following projects were not found in database: ",
              paste(missing_projects, collapse = ", "))
    }
    selected_projects <- intersect(include_projects, all_projects)
  } else {
    # Include all projects except excluded ones
    if (!is.null(exclude_projects)) {
      selected_projects <- setdiff(all_projects, exclude_projects)
    } else {
      selected_projects <- all_projects
    }
  }

  if (length(selected_projects) == 0) {
    stop("No projects selected after applying include/exclude criteria")
  }

  message("Creating MultiDromaSet with projects: ", paste(selected_projects, collapse = ", "))

  # Create MultiDromaSet
  multi_set <- createMultiDromaSetFromDatabase(
    project_names = selected_projects,
    db_path = db_path,
    load_metadata = load_metadata,
    auto_load = auto_load
  )

  return(multi_set)
}


